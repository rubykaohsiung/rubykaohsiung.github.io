<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>引擎入門 — Ruby on Rails Guides</title>
  <link rel="stylesheet" type="text/css" href="stylesheets/style.css" data-turbolinks-track="reload">
  <link rel="stylesheet" type="text/css" href="stylesheets/print.css" media="print">
  <link rel="stylesheet" type="text/css" href="stylesheets/highlight.css" data-turbolinks-track="reload">
  <link href="images/favicon.ico" rel="shortcut icon" type="image/x-icon" />
  <script src="javascripts/turbolinks.js" data-turbolinks-track="reload"></script>
  <script src="javascripts/clipboard.js" data-turbolinks-track="reload"></script>
  <script src="javascripts/guides.js" data-turbolinks-track="reload"></script>
  <meta property="og:title" content="引擎入門 — Ruby on Rails Guides" />
  <meta name="description" content="引擎入門在本指南中，您將瞭解引擎以及如何使用它們來提供 透過一個乾淨和非常 易於使用的介面。閱讀本指南後，您將瞭解： 是什麼造就了引擎。 如何產生引擎。 如何為引擎構建功能。 如何將引擎連線到應用程式中。 如何覆蓋應用程式中的引擎功能。 如何避免使用 Load 和 Configuration Hooks 載入 Rails 框架。" />
  <meta property="og:description" content="引擎入門在本指南中，您將瞭解引擎以及如何使用它們來提供 透過一個乾淨和非常 易於使用的介面。閱讀本指南後，您將瞭解： 是什麼造就了引擎。 如何產生引擎。 如何為引擎構建功能。 如何將引擎連線到應用程式中。 如何覆蓋應用程式中的引擎功能。 如何避免使用 Load 和 Configuration Hooks 載入 Rails 框架。" />
  <meta property="og:locale" content="en_US" />
  <meta property="og:site_name" content="Ruby on Rails Guides" />
  <meta property="og:image" content="https://avatars.githubusercontent.com/u/4223" />
  <meta property="og:type" content="website" />
</head>
<body class="guide">
  <div>
    <div id="version-badge">v7.0.0</div>
  </div>
  <div id="topNav">
    <div class="wrapper">
      <strong class="more-info-label">更多資訊請前往 <a href="https://rubyonrails.org/">rubyonrails.org:</a> </strong>
      <span class="red-button more-info-button">
        更多在 Ruby on Rails
      </span>
      <ul class="more-info-links s-hidden">
        <li class="more-info"><a href="https://weblog.rubyonrails.org/">部落格</a></li>
        <li class="more-info"><a href="https://guides.rubyonrails.org/">指南</a></li>
        <li class="more-info"><a href="https://api.rubyonrails.org/">API</a></li>
        <li class="more-info"><a href="https://discuss.rubyonrails.org/">論壇</a></li>
        <li class="more-info"><a href="https://github.com/rails/rails">在 GitHub 上做出貢獻</a></li>
      </ul>
    </div>
  </div>
  <div id="header">
    <div class="wrapper clearfix">
      <h1><a href="index.html" title="返回首頁">Guides.rubyonrails.org</a></h1>
      <ul class="nav">
        <li><a class="nav-item" href="index.html">首頁</a></li>
        <li class="guides-index guides-index-large">
          <a href="index.html" id="guidesMenu" class="guides-index-item nav-item">手冊目錄</a>
          <div id="guides" class="clearfix" style="display: none;">
            <hr />
            <dl class="guides-section-container">
                <div class="guides-section">
                  <dt>從這裡開始</dt>
                  <dd><a href="getting_started.html">Rails 入門</a></dd>
                </div>
                <div class="guides-section">
                  <dt>Models</dt>
                  <dd><a href="active_record_basics.html">Active Record 基礎</a></dd>
                  <dd><a href="active_record_migrations.html">Active Record 遷移 (Migrations)</a></dd>
                  <dd><a href="active_record_validations.html">Active Record 驗證 (Validations)</a></dd>
                  <dd><a href="active_record_callbacks.html">Active Record 回呼 (Callbacks)</a></dd>
                  <dd><a href="association_basics.html">Active Record 關聯 (Associations)</a></dd>
                  <dd><a href="active_record_querying.html">Active Record 查詢介面</a></dd>
                </div>
                <div class="guides-section">
                  <dt>Views</dt>
                  <dd><a href="layouts_and_rendering.html">Rails 中的版面配置(Layouts)和算繪(Rendering)</a></dd>
                  <dd><a href="form_helpers.html">Action View 表單 Helpers</a></dd>
                </div>
                <div class="guides-section">
                  <dt>Controllers</dt>
                  <dd><a href="action_controller_overview.html">Action Controller 概述</a></dd>
                  <dd><a href="routing.html">Rails 從外到內路由</a></dd>
                </div>
                <div class="guides-section">
                  <dt>其他元件</dt>
                  <dd><a href="active_support_core_extensions.html">Active Support 核心擴充套件</a></dd>
                  <dd><a href="action_mailer_basics.html">Action Mailer 基礎知識</a></dd>
                  <dd><a href="active_job_basics.html">Active Job 基礎</a></dd>
                  <dd><a href="active_storage_overview.html">Active Storage 概述</a></dd>
                  <dd><a href="action_cable_overview.html">Action Cable 概述</a></dd>
                  <dd><a href="webpacker.html">Webpacker</a></dd>
                </div>
                <div class="guides-section">
                  <dt>深入研究</dt>
                  <dd><a href="i18n.html">Rails 國際化 (I18n) API</a></dd>
                  <dd><a href="testing.html">測試 Rails 應用程式</a></dd>
                  <dd><a href="security.html">保護 Rails 應用程式</a></dd>
                  <dd><a href="debugging_rails_applications.html">除錯 Rails 應用程式</a></dd>
                  <dd><a href="configuring.html">設定 Rails 應用程式</a></dd>
                  <dd><a href="command_line.html">Rails 命令列</a></dd>
                  <dd><a href="asset_pipeline.html">Asset Pipeline</a></dd>
                  <dd><a href="autoloading_and_reloading_constants.html">自動載入和重新載入常量</a></dd>
                  <dd><a href="caching_with_rails.html">使用 Rails 快取</a></dd>
                  <dd><a href="api_app.html">將 Rails 用於僅 API 的應用程式</a></dd>
                </div>
                <div class="guides-section">
                  <dt>擴充 rails</dt>
                  <dd><a href="rails_on_rack.html">Rails on Rack</a></dd>
                  <dd><a href="generators.html">建立和自定義 Rails 產生器和模板</a></dd>
                </div>
                <div class="guides-section">
                  <dt>貢獻</dt>
                  <dd><a href="contributing_to_ruby_on_rails.html">在 Rails 上為 Ruby 做貢獻</a></dd>
                  <dd><a href="api_documentation_guidelines.html">API 文件指南</a></dd>
                  <dd><a href="ruby_on_rails_guides_guidelines.html">指南指南</a></dd>
                </div>
                <div class="guides-section">
                  <dt>政策</dt>
                  <dd><a href="maintenance_policy.html">維修政策</a></dd>
                </div>
                <div class="guides-section">
                  <dt>發行說明</dt>
                  <dd><a href="upgrading_ruby_on_rails.html">在 Rails 上升級 Ruby</a></dd>
                  <dd><a href="6_1_release_notes.html">6.1 版 - 2020 年 12 月</a></dd>
                  <dd><a href="6_0_release_notes.html">6.0 版 - 2019 年 8 月</a></dd>
                  <dd><a href="5_2_release_notes.html">5.2 版 - 2018 年 4 月</a></dd>
                  <dd><a href="5_1_release_notes.html">5.1 版 - 2017 年 4 月</a></dd>
                  <dd><a href="5_0_release_notes.html">5.0 版 - 2016 年 6 月</a></dd>
                  <dd><a href="4_2_release_notes.html">4.2 版 - 2014 年 12 月</a></dd>
                  <dd><a href="4_1_release_notes.html">4.1 版 - 2014 年 4 月</a></dd>
                  <dd><a href="4_0_release_notes.html">4.0 版 - 2013 年 6 月</a></dd>
                  <dd><a href="3_2_release_notes.html">3.2 版 - 2012 年 1 月</a></dd>
                  <dd><a href="3_1_release_notes.html">3.1 版 - 2011 年 8 月</a></dd>
                  <dd><a href="3_0_release_notes.html">3.0 版 - 2010 年 8 月</a></dd>
                  <dd><a href="2_3_release_notes.html">2.3 版 - 2009 年 3 月</a></dd>
                  <dd><a href="2_2_release_notes.html">2.2 版 - 2008 年 11 月</a></dd>
                </div>
            </dl>
          </div>
        </li>
        <li><a class="nav-item" href="contributing_to_ruby_on_rails.html">貢獻</a></li>
        <li class="guides-index guides-index-small">
          <select class="guides-index-item nav-item">
            <option value="index.html">手冊目錄</option>
              <optgroup label="從這裡開始">
                  <option value="getting_started.html">Rails 入門</option>
              </optgroup>
              <optgroup label="Models">
                  <option value="active_record_basics.html">Active Record 基礎</option>
                  <option value="active_record_migrations.html">Active Record 遷移 (Migrations)</option>
                  <option value="active_record_validations.html">Active Record 驗證 (Validations)</option>
                  <option value="active_record_callbacks.html">Active Record 回呼 (Callbacks)</option>
                  <option value="association_basics.html">Active Record 關聯 (Associations)</option>
                  <option value="active_record_querying.html">Active Record 查詢介面</option>
              </optgroup>
              <optgroup label="Views">
                  <option value="layouts_and_rendering.html">Rails 中的版面配置(Layouts)和算繪(Rendering)</option>
                  <option value="form_helpers.html">Action View 表單 Helpers</option>
              </optgroup>
              <optgroup label="Controllers">
                  <option value="action_controller_overview.html">Action Controller 概述</option>
                  <option value="routing.html">Rails 從外到內路由</option>
              </optgroup>
              <optgroup label="其他元件">
                  <option value="active_support_core_extensions.html">Active Support 核心擴充套件</option>
                  <option value="action_mailer_basics.html">Action Mailer 基礎知識</option>
                  <option value="active_job_basics.html">Active Job 基礎</option>
                  <option value="active_storage_overview.html">Active Storage 概述</option>
                  <option value="action_cable_overview.html">Action Cable 概述</option>
                  <option value="webpacker.html">Webpacker</option>
              </optgroup>
              <optgroup label="深入研究">
                  <option value="i18n.html">Rails 國際化 (I18n) API</option>
                  <option value="testing.html">測試 Rails 應用程式</option>
                  <option value="security.html">保護 Rails 應用程式</option>
                  <option value="debugging_rails_applications.html">除錯 Rails 應用程式</option>
                  <option value="configuring.html">設定 Rails 應用程式</option>
                  <option value="command_line.html">Rails 命令列</option>
                  <option value="asset_pipeline.html">Asset Pipeline</option>
                  <option value="autoloading_and_reloading_constants.html">自動載入和重新載入常量</option>
                  <option value="caching_with_rails.html">使用 Rails 快取</option>
                  <option value="api_app.html">將 Rails 用於僅 API 的應用程式</option>
              </optgroup>
              <optgroup label="擴充 rails">
                  <option value="rails_on_rack.html">Rails on Rack</option>
                  <option value="generators.html">建立和自定義 Rails 產生器和模板</option>
              </optgroup>
              <optgroup label="貢獻">
                  <option value="contributing_to_ruby_on_rails.html">在 Rails 上為 Ruby 做貢獻</option>
                  <option value="api_documentation_guidelines.html">API 文件指南</option>
                  <option value="ruby_on_rails_guides_guidelines.html">指南指南</option>
              </optgroup>
              <optgroup label="政策">
                  <option value="maintenance_policy.html">維修政策</option>
              </optgroup>
              <optgroup label="發行說明">
                  <option value="upgrading_ruby_on_rails.html">在 Rails 上升級 Ruby</option>
                  <option value="6_1_release_notes.html">6.1 版 - 2020 年 12 月</option>
                  <option value="6_0_release_notes.html">6.0 版 - 2019 年 8 月</option>
                  <option value="5_2_release_notes.html">5.2 版 - 2018 年 4 月</option>
                  <option value="5_1_release_notes.html">5.1 版 - 2017 年 4 月</option>
                  <option value="5_0_release_notes.html">5.0 版 - 2016 年 6 月</option>
                  <option value="4_2_release_notes.html">4.2 版 - 2014 年 12 月</option>
                  <option value="4_1_release_notes.html">4.1 版 - 2014 年 4 月</option>
                  <option value="4_0_release_notes.html">4.0 版 - 2013 年 6 月</option>
                  <option value="3_2_release_notes.html">3.2 版 - 2012 年 1 月</option>
                  <option value="3_1_release_notes.html">3.1 版 - 2011 年 8 月</option>
                  <option value="3_0_release_notes.html">3.0 版 - 2010 年 8 月</option>
                  <option value="2_3_release_notes.html">2.3 版 - 2009 年 3 月</option>
                  <option value="2_2_release_notes.html">2.2 版 - 2008 年 11 月</option>
              </optgroup>
          </select>
        </li>
      </ul>
    </div>
  </div>
  <hr class="hide" />

  <div id="feature">
    <div class="wrapper">
      <h2>引擎入門</h2><p>在本指南中，您將瞭解引擎以及如何使用它們來提供
透過一個乾淨和非常
易於使用的介面。</p><p>閱讀本指南後，您將瞭解：</p>
<ul>
<li>是什麼造就了引擎。</li>
<li>如何產生引擎。</li>
<li>如何為引擎構建功能。</li>
<li>如何將引擎連線到應用程式中。</li>
<li>如何覆蓋應用程式中的引擎功能。</li>
<li>如何避免使用 Load 和 Configuration Hooks 載入 Rails 框架。</li>
</ul>


                <div id="subCol">
            <h3 class="chapter"><img src="images/chapters_icon.gif" alt="" />Chapters</h3>
            <ol class="chapters">
<li><a href="#">什麼是發動機？</a></li>
<li>
<a href="#">產生引擎</a>

<ul>
<li><a href="#">引擎內部</a></li>
</ul>
</li>
<li>
<a href="#">提供引擎功能</a>

<ul>
<li><a href="#">產生文章資源</a></li>
<li><a href="#">產生評論資源</a></li>
</ul>
</li>
<li>
<a href="#">連線到應用程式</a>

<ul>
<li><a href="#">安裝發動機</a></li>
<li><a href="#">引擎設定</a></li>
<li><a href="#">使用應用程式提供的類</a></li>
<li><a href="#">設定引擎</a></li>
</ul>
</li>
<li>
<a href="#">測試引擎</a>

<ul>
<li><a href="#">功能測試</a></li>
</ul>
</li>
<li>
<a href="#">改進引擎功能</a>

<ul>
<li><a href="#models-controllers">覆蓋 Models 和 Controllers</a></li>
<li><a href="#">自動載入和引擎</a></li>
<li><a href="#views">覆蓋 Views</a></li>
<li><a href="#">路線</a></li>
<li><a href="#">資產</a></li>
<li><a href="#">分離資產和預編譯</a></li>
<li><a href="#gem">其他 Gem 依賴</a></li>
</ul>
</li>
<li>
<a href="#">載入和設定掛鉤</a>

<ul>
<li><a href="#rails">避免載入 Rails 框架</a></li>
<li><a href="#hooks">什麼時候呼叫 Hooks？</a></li>
<li><a href="#load-hooks">修改程式碼使用Load Hooks</a></li>
<li><a href="#">可用的負載掛鉤</a></li>
<li><a href="#">可用的設定掛載機制</a></li>
</ul>
</li>
</ol>

          </div>

    </div>
  </div>

  <div id="container">
    <div class="wrapper">
      <div id="mainCol">
        <h3 id=""><a class="anchorlink" href="#">1 什麼是發動機？</a></h3><p>引擎可以被認為是提供功能的微型應用程式
他們的主機應用程式。 Rails 應用實際上只是一個“增壓”
引擎，其中 <code>Rails::Application</code> 類繼承了它的許多行為
來自 <code>Rails::Engine</code>。</p><p>因此，引擎和應用程式幾乎可以被認為是一回事，
正如您將在本指南中看到的那樣，只是有細微的差別。發動機和
應用程式也共享一個共同的結構。</p><p>引擎也與外掛密切相關。兩者共享一個共同的<code>lib</code>
目錄結構，並且都是使用 <code>rails plugin new</code> 產生的
發電機。不同之處在於引擎被視為“完整外掛”
Rails（由傳遞給產生器的 <code>--full</code> 選項指示
命令）。我們實際上將在這裡使用 <code>--mountable</code> 選項，其中包括
<code>--full</code> 的所有功能，然後是一些。本指南將參考這些
“完整的外掛”在整個過程中只是作為“引擎”。引擎<strong>可以</strong>是外掛，
一個外掛<strong>可以</strong>是一個引擎。</p><p>本指南中將建立的引擎將被稱為“blorgh”。這
引擎將為其主機應用程式提供部落格功能，允許
用於建立新文章和評論。在本指南的開頭，您
將僅在引擎本身內工作，但在後面的部分中，您將
瞭解如何將其掛接到應用程式中。</p><p>引擎也可以與其宿主應用程式隔離。這意味著一個
應用程式能夠擁有由路由 helper 提供的路徑，例如
<code>articles_path</code> 並使用一個引擎，該引擎也提供了一個路徑，也稱為
<code>articles_path</code>，兩者不會衝突。與此同時，controllers、models
和表名也是名稱空間的。稍後您將看到如何執行此操作
指導。</p><p>重要的是要始終牢記應用程式應該
<strong>始終</strong>優先於其引擎。應用程式是物件
對其環境中發生的事情有最終決定權。發動機應
只是加強它，而不是徹底改變它。</p><p>要檢視其他引擎的演示，請檢視
<a href="https://github.com/plataformatec/devise">設計</a>，一個提供
對其父應用程式的身份驗證，或
<a href="https://github.com/thredded/thredded">Thredded</a>，一個提供論壇的引擎
功能。還有 <a href="https://github.com/spree/spree">Spree</a>
提供電子商務平臺，以及
<a href="https://github.com/refinery/refinerycms">煉油CMS</a>，一個CMS引擎。</p><p>最後，如果沒有詹姆斯亞當的工作，引擎是不可能出現的，
Piotr Sarnacki、Rails 核心團隊和其他一些人。如果你曾經
遇見他們，別忘了說聲謝謝！</p><h3 id=""><a class="anchorlink" href="#">2 產生引擎</a></h3><p>要產生引擎，您需要執行外掛產生器並傳遞它
根據需要選擇合適的選項。對於“blorgh”示例，您需要
建立一個“可安裝”引擎，在終端中執行此命令：</p><div class="code_container">
<pre><code class="highlight console"><span class="gp">$</span><span class="w"> </span><span class="nb">rails </span>plugin new blorgh <span class="nt">--mountable</span>
</code></pre>
<button class="clipboard-button" data-clipboard-text="rails plugin new blorgh --mountable
">Copy</button>
</div>
<p>可以透過鍵入以下內容檢視外掛產生器的完整選項列表：</p><div class="code_container">
<pre><code class="highlight console"><span class="gp">$</span><span class="w"> </span><span class="nb">rails </span>plugin <span class="nt">--help</span>
</code></pre>
<button class="clipboard-button" data-clipboard-text="rails plugin --help
">Copy</button>
</div>
<p><code>--mountable</code> 選項告訴產生器您要建立一個
“可安裝”和名稱空間隔離引擎。該產生器將提供相同的
骨架結構與 <code>--full</code> 選項一樣。 <code>--full</code> 選項告訴
要建立引擎的產生器，包括骨架結構
這提供了以下內容：</p>
<ul>
<li>
<code>app</code> 目錄樹</li>
<li>
<p><code>config/routes.rb</code> 檔案：</p>
<div class="code_container">
<pre><code class="highlight ruby"><span class="no">Rails</span><span class="p">.</span><span class="nf">application</span><span class="p">.</span><span class="nf">routes</span><span class="p">.</span><span class="nf">draw</span> <span class="k">do</span>
<span class="k">end</span>
</code></pre>
<button class="clipboard-button" data-clipboard-text="Rails.application.routes.draw do
end
">Copy</button>
</div>
</li>
<li>
<p>位於 <code>lib/blorgh/engine.rb</code> 的檔案，其功能與
標準 Rails 應用程式的 <code>config/application.rb</code> 檔案：</p>
<div class="code_container">
<pre><code class="highlight ruby"><span class="k">module</span> <span class="nn">Blorgh</span>
  <span class="k">class</span> <span class="nc">Engine</span> <span class="o">&lt;</span> <span class="o">::</span><span class="no">Rails</span><span class="o">::</span><span class="no">Engine</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre>
<button class="clipboard-button" data-clipboard-text="module Blorgh
  class Engine &lt; ::Rails::Engine
  end
end
">Copy</button>
</div>
</li>
</ul>
<p><code>--mountable</code> 選項將新增到 <code>--full</code> 選項中：</p>
<ul>
<li>資產清單檔案（<code>blorgh_manifest.js</code> 和 <code>application.css</code>）</li>
<li>名稱空間的 <code>ApplicationController</code> 存根</li>
<li>名稱空間的 <code>ApplicationHelper</code> 存根</li>
<li>引擎的佈局 view 模板</li>
<li>
<p>名稱空間隔離到 <code>config/routes.rb</code>：</p>
<div class="code_container">
<pre><code class="highlight ruby"><span class="no">Blorgh</span><span class="o">::</span><span class="no">Engine</span><span class="p">.</span><span class="nf">routes</span><span class="p">.</span><span class="nf">draw</span> <span class="k">do</span>
<span class="k">end</span>
</code></pre>
<button class="clipboard-button" data-clipboard-text="Blorgh::Engine.routes.draw do
end
">Copy</button>
</div>
</li>
<li>
<p>名稱空間隔離到 <code>lib/blorgh/engine.rb</code>：</p>
<div class="code_container">
<pre><code class="highlight ruby"><span class="k">module</span> <span class="nn">Blorgh</span>
  <span class="k">class</span> <span class="nc">Engine</span> <span class="o">&lt;</span> <span class="o">::</span><span class="no">Rails</span><span class="o">::</span><span class="no">Engine</span>
    <span class="n">isolate_namespace</span> <span class="no">Blorgh</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre>
<button class="clipboard-button" data-clipboard-text="module Blorgh
  class Engine &lt; ::Rails::Engine
    isolate_namespace Blorgh
  end
end
">Copy</button>
</div>
</li>
</ul>
<p>此外，<code>--mountable</code> 選項告訴產生器安裝引擎
在位於 <code>test/dummy</code> 的虛擬測試應用程式中新增
跟隨虛擬應用程式的路由檔案在
<code>test/dummy/config/routes.rb</code>：</p><div class="code_container">
<pre><code class="highlight ruby"><span class="n">mount</span> <span class="no">Blorgh</span><span class="o">::</span><span class="no">Engine</span> <span class="o">=&gt;</span> <span class="s2">"/blorgh"</span>
</code></pre>
<button class="clipboard-button" data-clipboard-text='mount Blorgh::Engine =&gt; "/blorgh"
'>Copy</button>
</div>
<h4 id=""><a class="anchorlink" href="#">2.1 引擎內部</a></h4><h5 id=""><a class="anchorlink" href="#">2.1.1 關鍵檔案</a></h5><p>在這個全新引擎目錄的根目錄下有一個 <code>blorgh.gemspec</code> 檔案。
當您稍後將引擎包含到應用程式中時，您將使用
Rails 應用程式的 <code>Gemfile</code> 中的這一行：</p><div class="code_container">
<pre><code class="highlight ruby"><span class="n">gem</span> <span class="s1">'blorgh'</span><span class="p">,</span> <span class="ss">path: </span><span class="s1">'engines/blorgh'</span>
</code></pre>
<button class="clipboard-button" data-clipboard-text="gem 'blorgh', path: 'engines/blorgh'
">Copy</button>
</div>
<p>不要忘記像往常一樣執行 <code>bundle install</code>。透過將其指定為 gem 內
<code>Gemfile</code>，Bundler 會載入它，解析這個 <code>blorgh.gemspec</code> 檔案
並且需要 <code>lib</code> 目錄中的一個名為 <code>lib/blorgh.rb</code> 的檔案。這
檔案需要 <code>blorgh/engine.rb</code> 檔案（位於 <code>lib/blorgh/engine.rb</code>）
並定義了一個名為 <code>Blorgh</code> 的基礎 module。</p><div class="code_container">
<pre><code class="highlight ruby"><span class="nb">require</span> <span class="s2">"blorgh/engine"</span>

<span class="k">module</span> <span class="nn">Blorgh</span>
<span class="k">end</span>
</code></pre>
<button class="clipboard-button" data-clipboard-text='require "blorgh/engine"

module Blorgh
end
'>Copy</button>
</div>
<p>提示：有些引擎選擇使用這個檔案來放置全域性設定選項
為他們的引擎。這是一個相對不錯的主意，所以如果你想提供
設定選項，定義引擎的 <code>module</code> 的檔案是
完美的。將方法放在 module 中，您就可以開始使用了。</p><p>在 <code>lib/blorgh/engine.rb</code> 中是引擎的基類：</p><div class="code_container">
<pre><code class="highlight ruby"><span class="k">module</span> <span class="nn">Blorgh</span>
  <span class="k">class</span> <span class="nc">Engine</span> <span class="o">&lt;</span> <span class="o">::</span><span class="no">Rails</span><span class="o">::</span><span class="no">Engine</span>
    <span class="n">isolate_namespace</span> <span class="no">Blorgh</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre>
<button class="clipboard-button" data-clipboard-text="module Blorgh
  class Engine &lt; ::Rails::Engine
    isolate_namespace Blorgh
  end
end
">Copy</button>
</div>
<p>透過繼承 <code>Rails::Engine</code> 類，這個 gem 通知 Rails
在指定路徑有一個引擎，並且會正確安裝引擎
在應用程式內部，執行諸如新增 <code>app</code> 目錄的任務
引擎到 models、郵件程式、controllers 和 views 的載入路徑。</p><p>這裡的 <code>isolate_namespace</code> 方法值得特別注意。這個電話是
負責隔離 controllers、models、路由等
他們自己的名稱空間，遠離應用程式內部的類似元件。
沒有這個，發動機的部件就有可能“洩漏”
進入應用程式，導致不必要的中斷，或那個重要的引擎
元件可以被應用程式中類似命名的東西覆蓋。
此類衝突的示例之一是 helpers。不打電話
<code>isolate_namespace</code>，引擎的 helpers 將包含在應用程式的
controllers。</p><div class="note"><p><strong>強烈</strong>建議保留 <code>isolate_namespace</code> 線
在 <code>Engine</code> 類定義中。沒有它，引擎中產生的類
<strong>可能</strong>與應用程式衝突。</p></div><p>名稱空間的這種隔離意味著呼叫產生的 model
到<code>bin/rails generate model</code>，比如<code>bin/rails generate model article</code>，就不會叫<code>Article</code>，而是
取而代之的是名稱空間並稱為 <code>Blorgh::Article</code>。此外，該表為
model 是名稱空間的，變成了 <code>blorgh_articles</code>，而不是簡單的 <code>articles</code>。
類似於 model 名稱空間，一個名為 <code>ArticlesController</code> 的 controller 變成
<code>Blorgh::ArticlesController</code> 和該 controller 的 views 不會在
<code>app/views/articles</code>，而是 <code>app/views/blorgh/articles</code>。郵寄、工作
和 helpers 也是名稱空間的。</p><p>最後，路由也將在引擎內隔離。這是最
關於名稱空間的重要部分，稍後將在
本指南的 <a href="#routes">路線</a> 部分。</p><h5 id="app"><a class="anchorlink" href="#app">2.1.2 <code>app</code> 目錄</a></h5><p><code>app</code>目錄裡面是標準的<code>assets</code>、<code>controllers</code>、<code>helpers</code>、
您應該熟悉的 <code>jobs</code>、<code>mailers</code>、<code>models</code> 和 <code>views</code> 目錄
從應用程式。當我們編寫引擎時，我們將在以後的部分中更多地研究 models。</p><p>在 <code>app/assets</code> 目錄中，有 <code>images</code> 和
<code>stylesheets</code> 目錄，您應該再次熟悉，因為它們
應用程式的相似性。然而，這裡的一個差別是，每個
directory 包含一個帶有引擎名稱的子目錄。因為這個引擎是
將要名稱空間，它的資產也應該是。</p><p>在 <code>app/controllers</code> 目錄中有一個 <code>blorgh</code> 目錄
包含一個名為 <code>application_controller.rb</code> 的檔案。該檔案將提供任何
引擎的 controllers 的通用功能。 <code>blorgh</code> 目錄
是引擎的另一個 controllers 所在的位置。透過將它們放在
這個名稱空間目錄，你可以防止它們與
同名的 controllers 在其他引擎中甚至在
應用。</p><div class="note"><p>引擎內的 <code>ApplicationController</code> 類的命名就像
Rails 應用程式，以便您更輕鬆地轉換您的
應用到引擎中。</p></div><div class="note"><p>如果父應用程式在 <code>classic</code> 模式下執行，您可能會遇到
您的引擎 controller 從主應用程式繼承的情況
controller 而不是您引擎的應用程式 controller。最好的預防方法
這是在父應用程式中切換到 <code>zeitwerk</code> 模式。否則，使用
<code>require_dependency</code> 以確保引擎的應用程式 controller 是
載入。例如：</p></div><div class="code_container">
<pre><code class="highlight ruby"><span class="c1"># 僅在 `classic` 模式下需要。</span>
<span class="n">require_dependency</span> <span class="s2">"blorgh/application_controller"</span>

<span class="k">module</span> <span class="nn">Blorgh</span>
  <span class="k">class</span> <span class="nc">ArticlesController</span> <span class="o">&lt;</span> <span class="no">ApplicationController</span>
    <span class="c1"># ...</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre>
<button class="clipboard-button" data-clipboard-text='# 僅在 `classic` 模式下需要。
require_dependency "blorgh/application_controller"

module Blorgh
  class ArticlesController &lt; ApplicationController
    # ...
  end
end
'>Copy</button>
</div>
<div class="warning"><p>不要使用 <code>require</code> 因為它會破壞自動重新載入
開發環境中的類 - 使用 <code>require_dependency</code> 確保
類以正確的方式載入和解除安裝。</p></div><p>就像 <code>app/controllers</code> 一樣，你會在下面找到一個 <code>blorgh</code> 子目錄
<code>app/helpers</code>、<code>app/jobs</code>、<code>app/mailers</code> 和 <code>app/models</code> 目錄
包含關聯的 <code>application_*.rb</code> 檔案，用於收集常見的
功能。透過將您的檔案放在這個子目錄和名稱空間下
你的物件，你可以防止它們與同名的物件發生衝突
其他引擎甚至應用程式中的元素。</p><p>最後，<code>app/views</code> 目錄包含一個 <code>layouts</code> 資料夾，其中包含一個
檔案位於 <code>blorgh/application.html.erb</code>。此檔案允許您指定佈局
對於發動機。如果將此引擎用作獨立引擎，那麼您
將在此檔案中為其佈局新增任何自定義，而不是
應用程式的 <code>app/views/layouts/application.html.erb</code> 檔案。</p><p>如果您不想對引擎的使用者強制佈局，那麼您可以
刪除此檔案並在您的 controllers 中引用不同的佈局
引擎。</p><h5 id="bin"><a class="anchorlink" href="#bin">2.1.3 <code>bin</code> 目錄</a></h5><p>該目錄包含一個檔案 <code>bin/rails</code>，它使您能夠使用
<code>rails</code> 子命令和產生器，就像您在應用程式中一樣。
這意味著您將能夠為此產生新的 controllers 和 models
透過執行這樣的命令可以很容易地引擎引擎：</p><div class="code_container">
<pre><code class="highlight console"><span class="gp">$</span><span class="w"> </span><span class="nb">bin/rails </span>generate model
</code></pre>
<button class="clipboard-button" data-clipboard-text="bin/rails generate model
">Copy</button>
</div>
<p>當然，請記住，使用這些命令產生的任何內容
在 <code>Engine</code> 類中具有 <code>isolate_namespace</code> 的引擎將被名稱空間。</p><h5 id="test"><a class="anchorlink" href="#test">2.1.4 <code>test</code> 目錄</a></h5><p><code>test</code> 目錄是對引擎進行測試的地方。為了測試發動機，
有一個 Rails 應用程式的縮減版本嵌入其中
<code>test/dummy</code>。此應用程式將發動機安裝在
<code>test/dummy/config/routes.rb</code> 檔案：</p><div class="code_container">
<pre><code class="highlight ruby"><span class="no">Rails</span><span class="p">.</span><span class="nf">application</span><span class="p">.</span><span class="nf">routes</span><span class="p">.</span><span class="nf">draw</span> <span class="k">do</span>
  <span class="n">mount</span> <span class="no">Blorgh</span><span class="o">::</span><span class="no">Engine</span> <span class="o">=&gt;</span> <span class="s2">"/blorgh"</span>
<span class="k">end</span>
</code></pre>
<button class="clipboard-button" data-clipboard-text='Rails.application.routes.draw do
  mount Blorgh::Engine =&gt; "/blorgh"
end
'>Copy</button>
</div>
<p>此行將引擎安裝在路徑 <code>/blorgh</code> 處，這將使其可訪問
僅在該路徑上透過應用程式。</p><p>test目錄裡面有<code>test/integration</code>目錄，其中
應該放置引擎的整合測試。其他目錄可以
也在 <code>test</code> 目錄中建立。例如，您可能希望建立一個
<code>test/models</code> 目錄用於您的 model 測試。</p><h3 id=""><a class="anchorlink" href="#">3 提供引擎功能</a></h3><p>本指南包含的引擎提供提交文章和評論
功能並遵循與 <a href="getting_started.html">Getting Started
指南</a>，有一些新的曲折。</p><div class="note"><p>對於本節，請確保在根目錄中執行命令
<code>blorgh</code> 引擎的目錄。</p></div><h4 id=""><a class="anchorlink" href="#">3.1 產生文章資源</a></h4><p>為部落格引擎產生的第一件事是 <code>Article</code> model 和相關
controller。要快速產生它，您可以使用 Rails scaffold 產生器。</p><div class="code_container">
<pre><code class="highlight console"><span class="gp">$</span><span class="w"> </span><span class="nb">bin/rails </span>generate scaffold article title:string text:text
</code></pre>
<button class="clipboard-button" data-clipboard-text="bin/rails generate scaffold article title:string text:text
">Copy</button>
</div>
<p>此命令將輸出以下資訊：</p><div class="code_container">
<pre><code class="highlight plaintext">invoke  active_record
create    db/migrate/[timestamp]_create_blorgh_articles.rb
create    app/models/blorgh/article.rb
invoke    test_unit
create      test/models/blorgh/article_test.rb
create      test/fixtures/blorgh/articles.yml
invoke  resource_route
 route    resources :articles
invoke  scaffold_controller
create    app/controllers/blorgh/articles_controller.rb
invoke    erb
create      app/views/blorgh/articles
create      app/views/blorgh/articles/index.html.erb
create      app/views/blorgh/articles/edit.html.erb
create      app/views/blorgh/articles/show.html.erb
create      app/views/blorgh/articles/new.html.erb
create      app/views/blorgh/articles/_form.html.erb
invoke    test_unit
create      test/controllers/blorgh/articles_controller_test.rb
create      test/system/blorgh/articles_test.rb
invoke    helper
create      app/helpers/blorgh/articles_helper.rb
invoke      test_unit
</code></pre>
<button class="clipboard-button" data-clipboard-text="invoke  active_record
create    db/migrate/[timestamp]_create_blorgh_articles.rb
create    app/models/blorgh/article.rb
invoke    test_unit
create      test/models/blorgh/article_test.rb
create      test/fixtures/blorgh/articles.yml
invoke  resource_route
 route    resources :articles
invoke  scaffold_controller
create    app/controllers/blorgh/articles_controller.rb
invoke    erb
create      app/views/blorgh/articles
create      app/views/blorgh/articles/index.html.erb
create      app/views/blorgh/articles/edit.html.erb
create      app/views/blorgh/articles/show.html.erb
create      app/views/blorgh/articles/new.html.erb
create      app/views/blorgh/articles/_form.html.erb
invoke    test_unit
create      test/controllers/blorgh/articles_controller_test.rb
create      test/system/blorgh/articles_test.rb
invoke    helper
create      app/helpers/blorgh/articles_helper.rb
invoke      test_unit
">Copy</button>
</div>
<p>scaffold 產生器做的第一件事就是呼叫 <code>active_record</code>
產生器，它為資源產生一個 migration 和一個 model。注意這裡，
然而，migration 被稱為 <code>create_blorgh_articles</code> 而不是
通常的 <code>create_articles</code>。這是由於呼叫了 <code>isolate_namespace</code> 方法
<code>Blorgh::Engine</code> 類的定義。這裡的 model 也是名稱空間的，
被放置在 <code>app/models/blorgh/article.rb</code> 而不是 <code>app/models/article.rb</code> 由於
到 <code>Engine</code> 類中的 <code>isolate_namespace</code> 呼叫。</p><p>接下來為這個model呼叫<code>test_unit</code>產生器，產生一個model
在 <code>test/models/blorgh/article_test.rb</code> 測試（而不是
<code>test/models/article_test.rb</code>) 和 <code>test/fixtures/blorgh/articles.yml</code> 的固定裝置
（而不是 <code>test/fixtures/articles.yml</code>）。</p><p>之後，將資源的一行插入到 <code>config/routes.rb</code> 檔案中
對於發動機。這一行就是 <code>resources :articles</code>，把
引擎的 <code>config/routes.rb</code> 檔案變成這樣：</p><div class="code_container">
<pre><code class="highlight ruby"><span class="no">Blorgh</span><span class="o">::</span><span class="no">Engine</span><span class="p">.</span><span class="nf">routes</span><span class="p">.</span><span class="nf">draw</span> <span class="k">do</span>
  <span class="n">resources</span> <span class="ss">:articles</span>
<span class="k">end</span>
</code></pre>
<button class="clipboard-button" data-clipboard-text="Blorgh::Engine.routes.draw do
  resources :articles
end
">Copy</button>
</div>
<p>請注意，這裡的路線是在 <code>Blorgh::Engine</code> 物件上繪製的，而不是
<code>YourApp::Application</code> 類。這是為了限制發動機路線
到發動機本身，可以安裝在特定點，如圖所示
<a href="#test-directory">測試目錄</a> 部分。它還導致引擎的路由
與應用程式中的那些路由隔離。這
本指南的 <a href="#routes">Routes</a> 部分對其進行了詳細描述。</p><p>接下來呼叫<code>scaffold_controller</code>產生器，產生一個controller
稱為 <code>Blorgh::ArticlesController</code>（在
<code>app/controllers/blorgh/articles_controller.rb</code>) 及其相關的 views 在
<code>app/views/blorgh/articles</code>。此產生器還產生測試
controller（<code>test/controllers/blorgh/articles_controller_test.rb</code> 和 <code>test/system/blorgh/articles_test.rb</code>）和一個 helper（<code>app/helpers/blorgh/articles_helper.rb</code>）。</p><p>這個產生器建立的所有東西都被整齊地命名。 controller 的
類在 <code>Blorgh</code> module 中定義：</p><div class="code_container">
<pre><code class="highlight ruby"><span class="k">module</span> <span class="nn">Blorgh</span>
  <span class="k">class</span> <span class="nc">ArticlesController</span> <span class="o">&lt;</span> <span class="no">ApplicationController</span>
    <span class="c1"># ...</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre>
<button class="clipboard-button" data-clipboard-text="module Blorgh
  class ArticlesController &lt; ApplicationController
    # ...
  end
end
">Copy</button>
</div>
<div class="note"><p><code>ArticlesController</code> 類繼承自
<code>Blorgh::ApplicationController</code>，不是應用程式的 <code>ApplicationController</code>。</p></div><p><code>app/helpers/blorgh/articles_helper.rb</code> 中的 helper 也是名稱空間的：</p><div class="code_container">
<pre><code class="highlight ruby"><span class="k">module</span> <span class="nn">Blorgh</span>
  <span class="k">module</span> <span class="nn">ArticlesHelper</span>
    <span class="c1"># ...</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre>
<button class="clipboard-button" data-clipboard-text="module Blorgh
  module ArticlesHelper
    # ...
  end
end
">Copy</button>
</div>
<p>這有助於防止與可能具有的任何其他引擎或應用程式發生衝突
文章資源也是如此。</p><p>您可以透過在根目錄執行 <code>bin/rails db:migrate</code> 來檢視引擎到目前為止的內容
我們的引擎執行由 scaffold 產生器產生的 migration，然後
在 <code>test/dummy</code> 中執行 <code>bin/rails server</code>。當你開啟
<code>http://localhost:3000/blorgh/articles</code> 你會看到預設的 scaffold
被產生。點選周圍！你剛剛產生了你的第一個引擎
職能。</p><p>如果您更願意在控制檯中玩耍，<code>bin/rails console</code> 也可以正常工作
就像一個 Rails 應用程式。記住： <code>Article</code> model 是名稱空間的，所以要
引用它，您必須將其稱為 <code>Blorgh::Article</code>。</p><div class="code_container">
<pre><code class="highlight irb"><span class="gp">irb&gt;</span><span class="w"> </span><span class="no">Blorgh</span><span class="o">::</span><span class="no">Article</span><span class="p">.</span><span class="nf">find</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="p">=&gt;</span> <span class="kt">#&lt;</span><span class="no">Blorgh</span><span class="o">::</span><span class="no">Article</span> <span class="ss">id: </span><span class="mi">1</span> <span class="o">...</span><span class="kt">&gt;</span>
</code></pre>
<button class="clipboard-button" data-clipboard-text="Blorgh::Article.find(1)
">Copy</button>
</div>
<p>最後一件事是該引擎的 <code>articles</code> 資源應該是根
的發動機。每當有人進入引擎所在的根路徑時
安裝後，它們應該顯示一個文章列表。這可以發生，如果
這一行被插入到引擎內的 <code>config/routes.rb</code> 檔案中：</p><div class="code_container">
<pre><code class="highlight ruby"><span class="n">root</span> <span class="ss">to: </span><span class="s2">"articles#index"</span>
</code></pre>
<button class="clipboard-button" data-clipboard-text='root to: "articles#index"
'>Copy</button>
</div>
<p>現在人們只需要到引擎的根目錄就能看到所有的文章，而不是訪問 <code>/articles</code>。這意味著，而不是
<code>http://localhost:3000/blorgh/articles</code>，你只需要去
<code>http://localhost:3000/blorgh/articles</code>，你只需要去
<code>http://localhost:3000/blorgh</code> 現在。</p><h4 id=""><a class="anchorlink" href="#">3.2 產生評論資源</a></h4><p>既然引擎可以建立新文章，那麼新增才有意義
評論功能也是如此。為此，您需要產生評論
model，評論controller，然後修改文章scaffold顯示
評論並允許人們建立新的評論。</p><p>從引擎根目錄執行 model 產生器。告訴它產生一個
<code>Comment</code> model，相關表有兩列：一個 <code>article_id</code> 整數
和 <code>text</code> 文字列。</p><div class="code_container">
<pre><code class="highlight console"><span class="gp">$</span><span class="w"> </span><span class="nb">bin/rails </span>generate model Comment article_id:integer text:text
</code></pre>
<button class="clipboard-button" data-clipboard-text="bin/rails generate model Comment article_id:integer text:text
">Copy</button>
</div>
<p>這將輸出以下內容：</p><div class="code_container">
<pre><code class="highlight plaintext">invoke  active_record
create    db/migrate/[timestamp]_create_blorgh_comments.rb
create    app/models/blorgh/comment.rb
invoke    test_unit
create      test/models/blorgh/comment_test.rb
create      test/fixtures/blorgh/comments.yml
</code></pre>
<button class="clipboard-button" data-clipboard-text="invoke  active_record
create    db/migrate/[timestamp]_create_blorgh_comments.rb
create    app/models/blorgh/comment.rb
invoke    test_unit
create      test/models/blorgh/comment_test.rb
create      test/fixtures/blorgh/comments.yml
">Copy</button>
</div>
<p>這個產生器呼叫將只產生它需要的必要的 model 檔案，
命名 <code>blorgh</code> 目錄下的檔案並建立一個 model 類
稱為 <code>Blorgh::Comment</code>。現在執行 migration 來建立我們的 blorgh_comments
桌子：</p><div class="code_container">
<pre><code class="highlight console"><span class="gp">$</span><span class="w"> </span><span class="nb">bin/rails </span>db:migrate
</code></pre>
<button class="clipboard-button" data-clipboard-text="bin/rails db:migrate
">Copy</button>
</div>
<p>要顯示對文章的評論，請編輯 <code>app/views/blorgh/articles/show.html.erb</code> 和
在“編輯”連結之前新增此行：</p><div class="code_container">
<pre><code class="highlight erb"><span class="nt">&lt;h3&gt;</span>Comments<span class="nt">&lt;/h3&gt;</span>
<span class="cp">&lt;%=</span> <span class="n">render</span> <span class="vi">@article</span><span class="p">.</span><span class="nf">comments</span> <span class="cp">%&gt;</span>
</code></pre>
<button class="clipboard-button" data-clipboard-text="&lt;h3&gt;Comments&lt;/h3&gt;
&lt;%= render @article.comments %&gt;
">Copy</button>
</div>
<p>這一行將要求有一個 <code>has_many</code> association 來定義註釋
在 <code>Blorgh::Article</code> model 上，現在沒有。要定義一個，開啟
<code>app/models/blorgh/article.rb</code> 並將此行新增到 model 中：</p><div class="code_container">
<pre><code class="highlight ruby"><span class="n">has_many</span> <span class="ss">:comments</span>
</code></pre>
<button class="clipboard-button" data-clipboard-text="has_many :comments
">Copy</button>
</div>
<p>把 model 變成這樣：</p><div class="code_container">
<pre><code class="highlight ruby"><span class="k">module</span> <span class="nn">Blorgh</span>
  <span class="k">class</span> <span class="nc">Article</span> <span class="o">&lt;</span> <span class="no">ApplicationRecord</span>
    <span class="n">has_many</span> <span class="ss">:comments</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre>
<button class="clipboard-button" data-clipboard-text="module Blorgh
  class Article &lt; ApplicationRecord
    has_many :comments
  end
end
">Copy</button>
</div>
<div class="note"><p>因為 <code>has_many</code> 是在一個類中定義的
<code>Blorgh</code> module, Rails 會知道你要使用<code>Blorgh::Comment</code>
model 用於這些物件，因此無需指定使用
<code>:class_name</code> 選項在這裡。</p></div><p>接下來，需要有一個表單，以便可以在文章上建立評論。到
新增這個，把這一行放在對 <code>render @article.comments</code> 的呼叫下面
<code>app/views/blorgh/articles/show.html.erb</code>：</p><div class="code_container">
<pre><code class="highlight erb"><span class="cp">&lt;%=</span> <span class="n">render</span> <span class="s2">"blorgh/comments/form"</span> <span class="cp">%&gt;</span>
</code></pre>
<button class="clipboard-button" data-clipboard-text='&lt;%= render "blorgh/comments/form" %&gt;
'>Copy</button>
</div>
<p>接下來，該行將呈現的部分需要存在。建立一個新的
<code>app/views/blorgh/comments</code> 中的目錄，其中有一個名為
<code>_form.html.erb</code> 具有以下內容來建立所需的部分：</p><div class="code_container">
<pre><code class="highlight erb"><span class="nt">&lt;h3&gt;</span>New comment<span class="nt">&lt;/h3&gt;</span>
<span class="cp">&lt;%=</span> <span class="n">form_with</span> <span class="ss">model: </span><span class="p">[</span><span class="vi">@article</span><span class="p">,</span> <span class="vi">@article</span><span class="p">.</span><span class="nf">comments</span><span class="p">.</span><span class="nf">build</span><span class="p">]</span> <span class="k">do</span> <span class="o">|</span><span class="n">form</span><span class="o">|</span> <span class="cp">%&gt;</span>
  <span class="nt">&lt;p&gt;</span>
    <span class="cp">&lt;%=</span> <span class="n">form</span><span class="p">.</span><span class="nf">label</span> <span class="ss">:text</span> <span class="cp">%&gt;</span><span class="nt">&lt;br&gt;</span>
    <span class="cp">&lt;%=</span> <span class="n">form</span><span class="p">.</span><span class="nf">text_area</span> <span class="ss">:text</span> <span class="cp">%&gt;</span>
  <span class="nt">&lt;/p&gt;</span>
  <span class="cp">&lt;%=</span> <span class="n">form</span><span class="p">.</span><span class="nf">submit</span> <span class="cp">%&gt;</span>
<span class="cp">&lt;%</span> <span class="k">end</span> <span class="cp">%&gt;</span>
</code></pre>
<button class="clipboard-button" data-clipboard-text="&lt;h3&gt;New comment&lt;/h3&gt;
&lt;%= form_with model: [@article, @article.comments.build] do |form| %&gt;
  &lt;p&gt;
    &lt;%= form.label :text %&gt;&lt;br&gt;
    &lt;%= form.text_area :text %&gt;
  &lt;/p&gt;
  &lt;%= form.submit %&gt;
&lt;% end %&gt;
">Copy</button>
</div>
<p>提交此表單時，它將嘗試執行 <code>POST</code> 請求
到引擎內的 <code>/articles/:article_id/comments</code> 路線。這條路線不
目前存在，但可以通過更改 <code>resources :articles</code> 行來建立
在 <code>config/routes.rb</code> 內進入這些行：</p><div class="code_container">
<pre><code class="highlight ruby"><span class="n">resources</span> <span class="ss">:articles</span> <span class="k">do</span>
  <span class="n">resources</span> <span class="ss">:comments</span>
<span class="k">end</span>
</code></pre>
<button class="clipboard-button" data-clipboard-text="resources :articles do
  resources :comments
end
">Copy</button>
</div>
<p>這為評論建立了一個巢狀的路由，這正是表單所要求的。</p><p>該路由現在存在，但該路由去往的 controller 不存在。到
建立它，從引擎根執行此命令：</p><div class="code_container">
<pre><code class="highlight console"><span class="gp">$</span><span class="w"> </span><span class="nb">bin/rails </span>generate controller comments
</code></pre>
<button class="clipboard-button" data-clipboard-text="bin/rails generate controller comments
">Copy</button>
</div>
<p>這將產生以下內容：</p><div class="code_container">
<pre><code class="highlight plaintext">create  app/controllers/blorgh/comments_controller.rb
invoke  erb
 exist    app/views/blorgh/comments
invoke  test_unit
create    test/controllers/blorgh/comments_controller_test.rb
invoke  helper
create    app/helpers/blorgh/comments_helper.rb
invoke    test_unit
</code></pre>
<button class="clipboard-button" data-clipboard-text="create  app/controllers/blorgh/comments_controller.rb
invoke  erb
 exist    app/views/blorgh/comments
invoke  test_unit
create    test/controllers/blorgh/comments_controller_test.rb
invoke  helper
create    app/helpers/blorgh/comments_helper.rb
invoke    test_unit
">Copy</button>
</div>
<p>該表單將向 <code>/articles/:article_id/comments</code> 發出 <code>POST</code> 請求，其中
將對應於 <code>Blorgh::CommentsController</code> 中的 <code>create</code> action。這
需要建立action，可以通過放入以下幾行
在 <code>app/controllers/blorgh/comments_controller.rb</code> 中的類定義中：</p><div class="code_container">
<pre><code class="highlight ruby"><span class="k">def</span> <span class="nf">create</span>
  <span class="vi">@article</span> <span class="o">=</span> <span class="no">Article</span><span class="p">.</span><span class="nf">find</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="ss">:article_id</span><span class="p">])</span>
  <span class="vi">@comment</span> <span class="o">=</span> <span class="vi">@article</span><span class="p">.</span><span class="nf">comments</span><span class="p">.</span><span class="nf">create</span><span class="p">(</span><span class="n">comment_params</span><span class="p">)</span>
  <span class="n">flash</span><span class="p">[</span><span class="ss">:notice</span><span class="p">]</span> <span class="o">=</span> <span class="s2">"Comment has been created!"</span>
  <span class="n">redirect_to</span> <span class="n">articles_path</span>
<span class="k">end</span>

<span class="kp">private</span>
  <span class="k">def</span> <span class="nf">comment_params</span>
    <span class="n">params</span><span class="p">.</span><span class="nf">require</span><span class="p">(</span><span class="ss">:comment</span><span class="p">).</span><span class="nf">permit</span><span class="p">(</span><span class="ss">:text</span><span class="p">)</span>
  <span class="k">end</span>
</code></pre>
<button class="clipboard-button" data-clipboard-text='def create
  @article = Article.find(params[:article_id])
  @comment = @article.comments.create(comment_params)
  flash[:notice] = "Comment has been created!"
  redirect_to articles_path
end

private
  def comment_params
    params.require(:comment).permit(:text)
  end
'>Copy</button>
</div>
<p>這是使新的評論表單工作所需的最後一步。顯示
然而，這些評論還不完全正確。如果您要建立評論
現在，您會看到此錯誤：</p><div class="code_container">
<pre><code class="highlight plaintext">Missing partial blorgh/comments/_comment with {:handlers=&gt;[:erb, :builder],
:formats=&gt;[:html], :locale=&gt;[:en, :en]}. Searched in:   *
"/Users/ryan/Sites/side_projects/blorgh/test/dummy/app/views"   *
"/Users/ryan/Sites/side_projects/blorgh/app/views"
</code></pre>
<button class="clipboard-button" data-clipboard-text='Missing partial blorgh/comments/_comment with {:handlers=&gt;[:erb, :builder],
:formats=&gt;[:html], :locale=&gt;[:en, :en]}. Searched in:   *
"/Users/ryan/Sites/side_projects/blorgh/test/dummy/app/views"   *
"/Users/ryan/Sites/side_projects/blorgh/app/views"
'>Copy</button>
</div>
<p>引擎無法找到呈現評論所需的部分。
Rails 首先在應用程式的 (<code>test/dummy</code>) <code>app/views</code> 目錄中查詢，然後
然後在引擎的 <code>app/views</code> 目錄中。當它找不到它時，它會丟擲
這個錯誤。引擎知道尋找 <code>blorgh/comments/_comment</code> 因為
它接收的 model 物件來自 <code>Blorgh::Comment</code> 類。</p><p>目前，該部分將僅負責渲染評論文字。
在 <code>app/views/blorgh/comments/_comment.html.erb</code> 建立一個新檔案並將其放入
裡面的行：</p><div class="code_container">
<pre><code class="highlight erb"><span class="cp">&lt;%=</span> <span class="n">comment_counter</span> <span class="o">+</span> <span class="mi">1</span> <span class="cp">%&gt;</span>. <span class="cp">&lt;%=</span> <span class="n">comment</span><span class="p">.</span><span class="nf">text</span> <span class="cp">%&gt;</span>
</code></pre>
<button class="clipboard-button" data-clipboard-text="&lt;%= comment_counter + 1 %&gt;. &lt;%= comment.text %&gt;
">Copy</button>
</div>
<p><code>comment_counter</code> 區域性變數由 <code>&lt;%= 渲染器提供給我們
@article.comments %&gt;</code> 呼叫，它將自動定義它並增加
計數器，因為它遍歷每個評論。在這個例子中它用於
建立時在每條評論旁邊顯示一個小數字。</p><p>這樣就完成了部落格引擎的評論功能。現在是時候使用了
它在一個應用程式中。</p><h3 id=""><a class="anchorlink" href="#">4 連線到應用程式</a></h3><p>在應用程式中使用引擎非常容易。本節介紹如何
將引擎安裝到應用程式和所需的初始設定中，以及
將引擎連結到應用程式提供的 <code>User</code> 類以提供
引擎內文章和評論的所有權。</p><h4 id=""><a class="anchorlink" href="#">4.1 安裝發動機</a></h4><p>首先，需要在應用程式的 <code>Gemfile</code> 中指定引擎。如果
沒有一個應用程式可以方便地進行測試，請使用
引擎目錄外的 <code>rails new</code> 命令如下：</p><div class="code_container">
<pre><code class="highlight console"><span class="gp">$</span><span class="w"> </span><span class="nb">rails </span>new unicorn
</code></pre>
<button class="clipboard-button" data-clipboard-text="rails new unicorn
">Copy</button>
</div>
<p>通常，在 <code>Gemfile</code> 中指定引擎將通過指定它來完成
作為普通的日常寶石。</p><div class="code_container">
<pre><code class="highlight ruby"><span class="n">gem</span> <span class="s1">'devise'</span>
</code></pre>
<button class="clipboard-button" data-clipboard-text="gem 'devise'
">Copy</button>
</div>
<p>但是，因為您是在本地機器上開發 <code>blorgh</code> 引擎，
您需要在 <code>Gemfile</code> 中指定 <code>:path</code> 選項：</p><div class="code_container">
<pre><code class="highlight ruby"><span class="n">gem</span> <span class="s1">'blorgh'</span><span class="p">,</span> <span class="ss">path: </span><span class="s1">'engines/blorgh'</span>
</code></pre>
<button class="clipboard-button" data-clipboard-text="gem 'blorgh', path: 'engines/blorgh'
">Copy</button>
</div>
<p>然後執行 ​​<code>bundle</code> 來安裝 gem。</p><p>如前所述，通過將 gem 放置在 <code>Gemfile</code> 中，它將在
Rails 已載入。它首先需要來自引擎的 <code>lib/blorgh.rb</code>，然後
<code>lib/blorgh/engine.rb</code>，這是定義主要部分的檔案
發動機的功能。</p><p>為了使引擎的功能可以從應用程式中訪問，它
需要安裝在該應用程式的 <code>config/routes.rb</code> 檔案中：</p><div class="code_container">
<pre><code class="highlight ruby"><span class="n">mount</span> <span class="no">Blorgh</span><span class="o">::</span><span class="no">Engine</span><span class="p">,</span> <span class="ss">at: </span><span class="s2">"/blog"</span>
</code></pre>
<button class="clipboard-button" data-clipboard-text='mount Blorgh::Engine, at: "/blog"
'>Copy</button>
</div>
<p>此行將在應用程式中的 <code>/blog</code> 處安裝引擎。進行中
當應用程式使用 <code>bin/rails 執行時，可以在</code><a href="http://localhost:3000/blog%60">http://localhost:3000/blog`</a> 訪問
伺服器`。</p><div class="note"><p>其他引擎，例如 Devise，通過使
您在路由中指定自定義 helpers（例如 <code>devise_for</code>）。這些helpers
做完全相同的事情，在一個地方安裝引擎的功能部件
可定製的預定義路徑。</p></div><h4 id=""><a class="anchorlink" href="#">4.2 引擎設定</a></h4><p>引擎包含 <code>blorgh_articles</code> 和 <code>blorgh_comments</code> 的 migrations
需要在應用程式的資料庫中建立的表，以便
引擎的 models 可以正確查詢它們。將這些 migrations 複製到
應用程式從應用程式的根目錄執行以下命令：</p><div class="code_container">
<pre><code class="highlight console"><span class="gp">$</span><span class="w"> </span><span class="nb">bin/rails </span>blorgh:install:migrations
</code></pre>
<button class="clipboard-button" data-clipboard-text="bin/rails blorgh:install:migrations
">Copy</button>
</div>
<p>如果您有多個引擎需要複製 migrations，請使用
<code>railties:install:migrations</code> 代替：</p><div class="code_container">
<pre><code class="highlight console"><span class="gp">$</span><span class="w"> </span><span class="nb">bin/rails </span>railties:install:migrations
</code></pre>
<button class="clipboard-button" data-clipboard-text="bin/rails railties:install:migrations
">Copy</button>
</div>
<p>此命令第一次執行時，會複製所有的 migrations
從發動機。下次執行時，它只會複製到 migrations
還沒複製過來。此命令的第一次執行將輸出
像這樣的東西：</p><div class="code_container">
<pre><code class="highlight plaintext">Copied migration [timestamp_1]_create_blorgh_articles.blorgh.rb from blorgh
Copied migration [timestamp_2]_create_blorgh_comments.blorgh.rb from blorgh
</code></pre>
<button class="clipboard-button" data-clipboard-text="Copied migration [timestamp_1]_create_blorgh_articles.blorgh.rb from blorgh
Copied migration [timestamp_2]_create_blorgh_comments.blorgh.rb from blorgh
">Copy</button>
</div>
<p>第一個時間戳 (<code>[timestamp_1]</code>) 將是當前時間，第二個
時間戳 (<code>[timestamp_2]</code>) 將是當前時間加上一秒。原因
因為這是為了引擎的 migrations 在任何現有的之後執行
應用程式中的 migrations。</p><p>要在應用程式的上下文中執行這些 migrations，只需執行 <code>bin/rails
db:migrate</code>. When accessing the engine through <code>http://localhost:3000/blog</code>,
文章將是空的。這是因為在應用程式內部建立的表是
與引擎中建立的不同。來吧，玩弄
新安裝的發動機。你會發現它和當它只是一個
引擎。</p><p>如果您只想從一個引擎執行 migrations，您可以通過
指定 <code>SCOPE</code>：</p><div class="code_container">
<pre><code class="highlight console"><span class="gp">$</span><span class="w"> </span><span class="nb">bin/rails </span>db:migrate <span class="nv">SCOPE</span><span class="o">=</span>blorgh
</code></pre>
<button class="clipboard-button" data-clipboard-text="bin/rails db:migrate SCOPE=blorgh
">Copy</button>
</div>
<p>如果您想在刪除它之前恢復引擎的 migrations，這可能很有用。
要從 blorgh 引擎恢復所有 migrations，您可以執行以下程式碼：</p><div class="code_container">
<pre><code class="highlight console"><span class="gp">$</span><span class="w"> </span><span class="nb">bin/rails </span>db:migrate <span class="nv">SCOPE</span><span class="o">=</span>blorgh <span class="nv">VERSION</span><span class="o">=</span>0
</code></pre>
<button class="clipboard-button" data-clipboard-text="bin/rails db:migrate SCOPE=blorgh VERSION=0
">Copy</button>
</div>
<h4 id=""><a class="anchorlink" href="#">4.3 使用應用程式提供的類</a></h4><h5 id="model"><a class="anchorlink" href="#model">4.3.1 使用應用程式提供的 Model</a></h5><p>建立引擎時，它可能希望使用來自
應用程式提供引擎部件和部件之間的連結
應用程式。以<code>blorgh</code>引擎為例，發表文章和評論
有作者會很有意義。</p><p>一個典型的應用程式可能有一個 <code>User</code> 類，用於表示
文章或評論的作者。但可能有一種情況
應用程式將此類稱為不同的名稱，例如 <code>Person</code>。為了這
原因，引擎不應該專門為 <code>User</code> 硬編碼 associations
班級。</p><p>在這種情況下，為了簡單起見，應用程式將有一個名為 <code>User</code> 的類
代表應用程式的使用者（我們將開始製作這個
可進一步設定）。它可以在內部使用此命令產生
應用：</p><div class="code_container">
<pre><code class="highlight console"><span class="gp">$</span><span class="w"> </span><span class="nb">bin/rails </span>generate model user name:string
</code></pre>
<button class="clipboard-button" data-clipboard-text="bin/rails generate model user name:string
">Copy</button>
</div>
<p>此處需要執行 <code>bin/rails db:migrate</code> 命令以確保我們的
應用程式有 <code>users</code> 表供將來使用。</p><p>此外，為了簡單起見，文章表單將有一個名為的新文字欄位
<code>author_name</code>，使用者可以選擇放置他們的名字。然後發動機將
取這個名字並從中建立一個新的 <code>User</code> 物件，或者找到一個
已經有這個名字了。然後引擎會將文章與找到的或
建立了 <code>User</code> 物件。</p><p>首先，需要將 <code>author_name</code> 文字欄位新增到
<code>app/views/blorgh/articles/_form.html.erb</code> 部分在引擎內部。這可以
使用以下程式碼在 <code>title</code> 欄位上方新增：</p><div class="code_container">
<pre><code class="highlight erb"><span class="nt">&lt;div</span> <span class="na">class=</span><span class="s">"field"</span><span class="nt">&gt;</span>
  <span class="cp">&lt;%=</span> <span class="n">form</span><span class="p">.</span><span class="nf">label</span> <span class="ss">:author_name</span> <span class="cp">%&gt;</span><span class="nt">&lt;br&gt;</span>
  <span class="cp">&lt;%=</span> <span class="n">form</span><span class="p">.</span><span class="nf">text_field</span> <span class="ss">:author_name</span> <span class="cp">%&gt;</span>
<span class="nt">&lt;/div&gt;</span>
</code></pre>
<button class="clipboard-button" data-clipboard-text='&lt;div class="field"&gt;
  &lt;%= form.label :author_name %&gt;&lt;br&gt;
  &lt;%= form.text_field :author_name %&gt;
&lt;/div&gt;
'>Copy</button>
</div>
<p>接下來，我們需要將 <code>Blorgh::ArticlesController#article_params</code> 方法更新為
允許新的表單引數：</p><div class="code_container">
<pre><code class="highlight ruby"><span class="k">def</span> <span class="nf">article_params</span>
  <span class="n">params</span><span class="p">.</span><span class="nf">require</span><span class="p">(</span><span class="ss">:article</span><span class="p">).</span><span class="nf">permit</span><span class="p">(</span><span class="ss">:title</span><span class="p">,</span> <span class="ss">:text</span><span class="p">,</span> <span class="ss">:author_name</span><span class="p">)</span>
<span class="k">end</span>
</code></pre>
<button class="clipboard-button" data-clipboard-text="def article_params
  params.require(:article).permit(:title, :text, :author_name)
end
">Copy</button>
</div>
<p><code>Blorgh::Article</code> model 然後應該有一些程式碼來轉換 <code>author_name</code>
將欄位轉換為實際的 <code>User</code> 物件並將其關聯為該文章的 <code>author</code>
在儲存文章之前。它還需要設定一個 <code>attr_accessor</code>
對於此欄位，以便為其定義 setter 和 getter 方法。</p><p>為此，您需要為 <code>author_name</code> 新增 <code>attr_accessor</code>，即
association 為作者和 <code>before_validation</code> 呼叫
<code>app/models/blorgh/article.rb</code>。 <code>author</code> association 將被硬編碼到
<code>User</code> 類暫時。</p><div class="code_container">
<pre><code class="highlight ruby"><span class="nb">attr_accessor</span> <span class="ss">:author_name</span>
<span class="n">belongs_to</span> <span class="ss">:author</span><span class="p">,</span> <span class="ss">class_name: </span><span class="s2">"User"</span>

<span class="n">before_validation</span> <span class="ss">:set_author</span>

<span class="kp">private</span>
  <span class="k">def</span> <span class="nf">set_author</span>
    <span class="nb">self</span><span class="p">.</span><span class="nf">author</span> <span class="o">=</span> <span class="no">User</span><span class="p">.</span><span class="nf">find_or_create_by</span><span class="p">(</span><span class="ss">name: </span><span class="n">author_name</span><span class="p">)</span>
  <span class="k">end</span>
</code></pre>
<button class="clipboard-button" data-clipboard-text='attr_accessor :author_name
belongs_to :author, class_name: "User"

before_validation :set_author

private
  def set_author
    self.author = User.find_or_create_by(name: author_name)
  end
'>Copy</button>
</div>
<p>通過使用 <code>User</code> 類表示 <code>author</code> association 的物件，連結
在引擎和應用程式之間建立。必須有辦法
將 <code>blorgh_articles</code> 表中的記錄與
<code>users</code> 表。因為 association 被稱為 <code>author</code>，所以應該有一個
<code>author_id</code> 列新增到 <code>blorgh_articles</code> 表中。</p><p>要產生這個新列，請在引擎中執行以下命令：</p><div class="code_container">
<pre><code class="highlight console"><span class="gp">$</span><span class="w"> </span><span class="nb">bin/rails </span>generate migration add_author_id_to_blorgh_articles author_id:integer
</code></pre>
<button class="clipboard-button" data-clipboard-text="bin/rails generate migration add_author_id_to_blorgh_articles author_id:integer
">Copy</button>
</div>
<div class="note"><p>由於 migration 的名稱和它後面的列規範，Rails
將自動知道您要向特定表中新增一列，並且
將其寫入 migration 中。你不需要多說
這。</p></div><p>此 migration 將需要在應用程式上執行。要做到這一點，它必須首先
使用以下命令複製：</p><div class="code_container">
<pre><code class="highlight console"><span class="gp">$</span><span class="w"> </span><span class="nb">bin/rails </span>blorgh:install:migrations
</code></pre>
<button class="clipboard-button" data-clipboard-text="bin/rails blorgh:install:migrations
">Copy</button>
</div>
<p>請注意，此處僅複製了 <em>one</em> migration。這是因為第一
第一次執行此命令時複製了兩個 migrations。</p><div class="code_container">
<pre><code class="highlight plaintext">NOTE Migration [timestamp]_create_blorgh_articles.blorgh.rb from blorgh has been skipped. Migration with the same name already exists.
NOTE Migration [timestamp]_create_blorgh_comments.blorgh.rb from blorgh has been skipped. Migration with the same name already exists.
Copied migration [timestamp]_add_author_id_to_blorgh_articles.blorgh.rb from blorgh
</code></pre>
<button class="clipboard-button" data-clipboard-text="NOTE Migration [timestamp]_create_blorgh_articles.blorgh.rb from blorgh has been skipped. Migration with the same name already exists.
NOTE Migration [timestamp]_create_blorgh_comments.blorgh.rb from blorgh has been skipped. Migration with the same name already exists.
Copied migration [timestamp]_add_author_id_to_blorgh_articles.blorgh.rb from blorgh
">Copy</button>
</div>
<p>使用以下命令執行 migration：</p><div class="code_container">
<pre><code class="highlight console"><span class="gp">$</span><span class="w"> </span><span class="nb">bin/rails </span>db:migrate
</code></pre>
<button class="clipboard-button" data-clipboard-text="bin/rails db:migrate
">Copy</button>
</div>
<p>現在所有的部分都準備好了，一個 action 將發生，它將關聯
作者 - 由 <code>users</code> 表中的記錄表示 - 有一篇文章，
由引擎中的 <code>blorgh_articles</code> 表表示。</p><p>最後，作者的名字應該顯示在文章的頁面上。新增此程式碼
在 <code>app/views/blorgh/articles/show.html.erb</code> 內的“標題”輸出上方：</p><div class="code_container">
<pre><code class="highlight erb"><span class="nt">&lt;p&gt;</span>
  <span class="nt">&lt;b&gt;</span>Author:<span class="nt">&lt;/b&gt;</span>
  <span class="cp">&lt;%=</span> <span class="vi">@article</span><span class="p">.</span><span class="nf">author</span><span class="p">.</span><span class="nf">name</span> <span class="cp">%&gt;</span>
<span class="nt">&lt;/p&gt;</span>
</code></pre>
<button class="clipboard-button" data-clipboard-text="&lt;p&gt;
  &lt;b&gt;Author:&lt;/b&gt;
  &lt;%= @article.author.name %&gt;
&lt;/p&gt;
">Copy</button>
</div>
<h5 id="controller"><a class="anchorlink" href="#controller">4.3.2 使用應用程式提供的 Controller</a></h5><p>因為 Rails controllers 通常共享用於身份驗證之類的程式碼
並訪問 session 變數，它們從 <code>ApplicationController</code> 繼承
預設。 Rails 引擎，但是範圍是獨立於主引擎執行的
應用程式，因此每個引擎都會獲得一個作用域 <code>ApplicationController</code>。這
namespace 防止程式碼衝突，但經常引擎 controllers 需要訪問
主應用程式的 <code>ApplicationController</code> 中的方法。一個簡單的方法
提供此訪問許可權是將引擎的作用域 <code>ApplicationController</code> 更改為
從主應用程式的 <code>ApplicationController</code> 繼承。對於我們的博格
引擎這將通過改變來完成
<code>app/controllers/blorgh/application_controller.rb</code> 看起來像：</p><div class="code_container">
<pre><code class="highlight ruby"><span class="k">module</span> <span class="nn">Blorgh</span>
  <span class="k">class</span> <span class="nc">ApplicationController</span> <span class="o">&lt;</span> <span class="o">::</span><span class="no">ApplicationController</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre>
<button class="clipboard-button" data-clipboard-text="module Blorgh
  class ApplicationController &lt; ::ApplicationController
  end
end
">Copy</button>
</div>
<p>預設情況下，引擎的 controllers 繼承自
<code>Blorgh::ApplicationController</code>。因此，在進行此更改後，他們將擁有
訪問主應用程式的 <code>ApplicationController</code>，就好像它們是
主要應用程式的一部分。</p><p>此更改確實需要從 Rails 應用程式執行引擎
有一個 <code>ApplicationController</code>。</p><h4 id=""><a class="anchorlink" href="#">4.4 設定引擎</a></h4><p>本節介紹如何使 <code>User</code> 類可設定，其次是
發動機的一般設定提示。</p><h5 id=""><a class="anchorlink" href="#">4.4.1 在應用中設定設定設定</a></h5><p>下一步是在應用程式中製作代表一個<code>User</code>的類
為引擎定製。這是因為該類可能並不總是
<code>User</code>，如前所述。為了使此設定可定製，引擎
將有一個名為 <code>author_class</code> 的設定設定，用於
指定哪個類代表應用程式內的使用者。</p><p>要定義此設定設定，您應該在裡面使用 <code>mattr_accessor</code>
引擎的 <code>Blorgh</code> module。將此行新增到 <code>lib/blorgh.rb</code> 內
引擎：</p><div class="code_container">
<pre><code class="highlight ruby"><span class="n">mattr_accessor</span> <span class="ss">:author_class</span>
</code></pre>
<button class="clipboard-button" data-clipboard-text="mattr_accessor :author_class
">Copy</button>
</div>
<p>此方法的工作原理與其兄弟 <code>attr_accessor</code> 和 <code>cattr_accessor</code> 類似，但
在具有指定名稱的 module 上提供 setter 和 getter 方法。到
使用它，必須使用 <code>Blorgh.author_class</code> 來引用它。</p><p>下一步是將 <code>Blorgh::Article</code> model 切換到這個新設定。
改變這個 model 裡面的 <code>belongs_to</code> association
(<code>app/models/blorgh/article.rb</code>) 到這個：</p><div class="code_container">
<pre><code class="highlight ruby"><span class="n">belongs_to</span> <span class="ss">:author</span><span class="p">,</span> <span class="ss">class_name: </span><span class="no">Blorgh</span><span class="p">.</span><span class="nf">author_class</span>
</code></pre>
<button class="clipboard-button" data-clipboard-text="belongs_to :author, class_name: Blorgh.author_class
">Copy</button>
</div>
<p><code>Blorgh::Article</code> model 中的 <code>set_author</code> 方法也應該使用這個類：</p><div class="code_container">
<pre><code class="highlight ruby"><span class="nb">self</span><span class="p">.</span><span class="nf">author</span> <span class="o">=</span> <span class="no">Blorgh</span><span class="p">.</span><span class="nf">author_class</span><span class="p">.</span><span class="nf">constantize</span><span class="p">.</span><span class="nf">find_or_create_by</span><span class="p">(</span><span class="ss">name: </span><span class="n">author_name</span><span class="p">)</span>
</code></pre>
<button class="clipboard-button" data-clipboard-text="self.author = Blorgh.author_class.constantize.find_or_create_by(name: author_name)
">Copy</button>
</div>
<p>為了節省必須一直在 <code>author_class</code> 結果上呼叫 <code>constantize</code>，
你可以改寫裡面的 <code>author_class</code> getter 方法
<code>Blorgh</code> module 在 <code>lib/blorgh.rb</code> 檔案中總是呼叫 <code>constantize</code>
在返回結果之前儲存了 value：</p><div class="code_container">
<pre><code class="highlight ruby"><span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">author_class</span>
  <span class="vc">@@author_class</span><span class="p">.</span><span class="nf">constantize</span>
<span class="k">end</span>
</code></pre>
<button class="clipboard-button" data-clipboard-text="def self.author_class
  @@author_class.constantize
end
">Copy</button>
</div>
<p>這會將上述 <code>set_author</code> 的程式碼轉換為：</p><div class="code_container">
<pre><code class="highlight ruby"><span class="nb">self</span><span class="p">.</span><span class="nf">author</span> <span class="o">=</span> <span class="no">Blorgh</span><span class="p">.</span><span class="nf">author_class</span><span class="p">.</span><span class="nf">find_or_create_by</span><span class="p">(</span><span class="ss">name: </span><span class="n">author_name</span><span class="p">)</span>
</code></pre>
<button class="clipboard-button" data-clipboard-text="self.author = Blorgh.author_class.find_or_create_by(name: author_name)
">Copy</button>
</div>
<p>導致它的行為更短，更隱含。這
<code>author_class</code> 方法應該總是返回一個 <code>Class</code> 物件。</p><p>由於我們將 <code>author_class</code> 方法更改為返回 <code>Class</code> 而不是
<code>String</code>，我們還要修改我們在<code>Blorgh::Article</code>中的<code>belongs_to</code>定義
model：</p><div class="code_container">
<pre><code class="highlight ruby"><span class="n">belongs_to</span> <span class="ss">:author</span><span class="p">,</span> <span class="ss">class_name: </span><span class="no">Blorgh</span><span class="p">.</span><span class="nf">author_class</span><span class="p">.</span><span class="nf">to_s</span>
</code></pre>
<button class="clipboard-button" data-clipboard-text="belongs_to :author, class_name: Blorgh.author_class.to_s
">Copy</button>
</div>
<p>要在應用程式中設定此設定設定，初始化程式應該
使用。通過使用初始化程式，設定將在
應用程式啟動並呼叫引擎的models，可能依賴於此
設定設定存在。</p><p>在 <code>config/initializers/blorgh.rb</code> 內部建立一個新的初始化程式
安裝了 <code>blorgh</code> 引擎的應用程式並將此內容放入其中：</p><div class="code_container">
<pre><code class="highlight ruby"><span class="no">Blorgh</span><span class="p">.</span><span class="nf">author_class</span> <span class="o">=</span> <span class="s2">"User"</span>
</code></pre>
<button class="clipboard-button" data-clipboard-text='Blorgh.author_class = "User"
'>Copy</button>
</div>
<div class="warning"><p>這裡使用類的 <code>String</code> 版本非常重要，
而不是類本身。如果您要使用該類，Rails 會嘗試
載入該類，然後引用相關表。這可能導致
如果表尚不存在，則會出現問題。因此，一個 <code>String</code> 應該是
使用，然後在引擎中使用 <code>constantize</code> 轉換為類。</p></div><p>繼續嘗試建立一篇新文章。你會看到它在
和以前一樣，除了這次引擎使用設定
在 <code>config/initializers/blorgh.rb</code> 中設定以瞭解類是什麼。</p><p>現在沒有對類是什麼的嚴格依賴，只有 API 是什麼
類必須是。引擎只需要這個類來定義一個
<code>find_or_create_by</code> 方法返回該類的物件，要
建立時與文章相關聯。這個物件當然應該有
可以引用它的某種識別符號。</p><h5 id=""><a class="anchorlink" href="#">4.4.2 通用引擎設定</a></h5><p>在引擎中，有時您可能希望使用諸如
初始化程式、國際化或其他設定選項。最棒的
新聞是這些事情是完全可能的，因為一個 Rails 引擎共享
與 Rails 應用程式的功能大致相同。其實一個Rails
應用程式的功能實際上是由
引擎！</p><p>如果您希望使用初始化程式 - 應該在引擎啟動之前執行的程式碼
載入 - 它的位置是 <code>config/initializers</code> 資料夾。這個目錄的
功能在 <a href="configuring.html#initializers">Initializers
section</a> 的設定指南，並且有效
與目錄中的 <code>config/initializers</code> 目錄完全相同
應用。如果您想使用標準初始化程式，情況也是如此。</p><p>對於語言環境，只需將語言環境檔案放在 <code>config/locales</code> 目錄中，
就像在應用程式中一樣。</p><h3 id=""><a class="anchorlink" href="#">5 測試引擎</a></h3><p>產生引擎時，內部會建立一個較小的虛擬應用程式
它在 <code>test/dummy</code>。此應用程式用作發動機的安裝點，
使測試引擎變得極其簡單。您可以通過以下方式擴充套件此應用程式
從目錄中產生 controllers、models 或 views，然後使用
那些測試你的引擎。</p><p><code>test</code> 目錄應該像典型的 Rails 測試環境一樣對待，
允許進行單元、功能和整合測試。</p><h4 id=""><a class="anchorlink" href="#">5.1 功能測試</a></h4><p>編寫功能測試時值得考慮的一個問題是
測試將在應用程式上執行 - <code>test/dummy</code>
應用程式 - 而不是您的引擎。這是由於測試的設定
環境;引擎需要一個應用程式作為主機來測試其主要
功能，尤其是 controllers。這意味著如果你要製作一個
在 controller 的功能測試中，典型的 <code>GET</code> 到 controller 如下所示：</p><div class="code_container">
<pre><code class="highlight ruby"><span class="k">module</span> <span class="nn">Blorgh</span>
  <span class="k">class</span> <span class="nc">FooControllerTest</span> <span class="o">&lt;</span> <span class="no">ActionDispatch</span><span class="o">::</span><span class="no">IntegrationTest</span>
    <span class="kp">include</span> <span class="no">Engine</span><span class="p">.</span><span class="nf">routes</span><span class="p">.</span><span class="nf">url_helpers</span>

    <span class="k">def</span> <span class="nf">test_index</span>
      <span class="n">get</span> <span class="n">foos_url</span>
      <span class="c1"># ...</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre>
<button class="clipboard-button" data-clipboard-text="module Blorgh
  class FooControllerTest &lt; ActionDispatch::IntegrationTest
    include Engine.routes.url_helpers

    def test_index
      get foos_url
      # ...
    end
  end
end
">Copy</button>
</div>
<p>它可能無法正常工作。這是因為應用程式不知道如何
將這些請求路由到引擎，除非您明確告訴它<strong>如何</strong>。到
為此，您必須將 <code>@routes</code> 實例變數設定為引擎的路由集
在您的設定程式碼中：</p><div class="code_container">
<pre><code class="highlight ruby"><span class="k">module</span> <span class="nn">Blorgh</span>
  <span class="k">class</span> <span class="nc">FooControllerTest</span> <span class="o">&lt;</span> <span class="no">ActionDispatch</span><span class="o">::</span><span class="no">IntegrationTest</span>
    <span class="kp">include</span> <span class="no">Engine</span><span class="p">.</span><span class="nf">routes</span><span class="p">.</span><span class="nf">url_helpers</span>

    <span class="n">setup</span> <span class="k">do</span>
      <span class="vi">@routes</span> <span class="o">=</span> <span class="no">Engine</span><span class="p">.</span><span class="nf">routes</span>
    <span class="k">end</span>

    <span class="k">def</span> <span class="nf">test_index</span>
      <span class="n">get</span> <span class="n">foos_url</span>
      <span class="c1"># ...</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre>
<button class="clipboard-button" data-clipboard-text="module Blorgh
  class FooControllerTest &lt; ActionDispatch::IntegrationTest
    include Engine.routes.url_helpers

    setup do
      @routes = Engine.routes
    end

    def test_index
      get foos_url
      # ...
    end
  end
end
">Copy</button>
</div>
<p>這告訴應用程式您仍然要嚮應用程式執行 <code>GET</code> 請求
<code>index</code> action 這個controller，但是你想用引擎的路由來獲取
在那裡，而不是應用程式的那個。</p><p>這也確保引擎的 URL helpers 將在您的
測試。</p><h3 id=""><a class="anchorlink" href="#">6 改進引擎功能</a></h3><p>本節說明如何在
主 Rails 應用程式。</p><h4 id="models-controllers"><a class="anchorlink" href="#models-controllers">6.1 覆蓋 Models 和 Controllers</a></h4><p>引擎 models 和 controllers 可以被父應用程式重新開啟以擴充套件或裝飾它們。</p><p>覆蓋可以組織在專用目錄 <code>app/overrides</code> 中，該目錄預載入在 <code>to_prepare</code> callback 中。</p><p>在 <code>zeitwerk</code> 模式下，你會這樣做：</p><div class="code_container">
<pre><code class="highlight ruby"><span class="c1"># 設定/應用程式.rb</span>
<span class="k">module</span> <span class="nn">MyApp</span>
  <span class="k">class</span> <span class="nc">Application</span> <span class="o">&lt;</span> <span class="no">Rails</span><span class="o">::</span><span class="no">Application</span>
    <span class="c1"># ...</span>

    <span class="n">overrides</span> <span class="o">=</span> <span class="s2">"</span><span class="si">#{</span><span class="no">Rails</span><span class="p">.</span><span class="nf">root</span><span class="si">}</span><span class="s2">/app/overrides"</span>
    <span class="no">Rails</span><span class="p">.</span><span class="nf">autoloaders</span><span class="p">.</span><span class="nf">main</span><span class="p">.</span><span class="nf">ignore</span><span class="p">(</span><span class="n">overrides</span><span class="p">)</span>
    <span class="n">config</span><span class="p">.</span><span class="nf">to_prepare</span> <span class="k">do</span>
      <span class="no">Dir</span><span class="p">.</span><span class="nf">glob</span><span class="p">(</span><span class="s2">"</span><span class="si">#{</span><span class="n">overrides</span><span class="si">}</span><span class="s2">/**/*_override.rb"</span><span class="p">).</span><span class="nf">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">override</span><span class="o">|</span>
        <span class="nb">load</span> <span class="n">override</span>
      <span class="k">end</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre>
<button class="clipboard-button" data-clipboard-text='# 設定/應用程式.rb
module MyApp
  class Application &lt; Rails::Application
    # ...

    overrides = "#{Rails.root}/app/overrides"
    Rails.autoloaders.main.ignore(overrides)
    config.to_prepare do
      Dir.glob("#{overrides}/**/*_override.rb").each do |override|
        load override
      end
    end
  end
end
'>Copy</button>
</div>
<p>在 <code>classic</code> 模式下：</p><div class="code_container">
<pre><code class="highlight ruby"><span class="c1"># 設定/應用程式.rb</span>
<span class="k">module</span> <span class="nn">MyApp</span>
  <span class="k">class</span> <span class="nc">Application</span> <span class="o">&lt;</span> <span class="no">Rails</span><span class="o">::</span><span class="no">Application</span>
    <span class="c1"># ...</span>

    <span class="n">config</span><span class="p">.</span><span class="nf">to_prepare</span> <span class="k">do</span>
      <span class="no">Dir</span><span class="p">.</span><span class="nf">glob</span><span class="p">(</span><span class="s2">"</span><span class="si">#{</span><span class="no">Rails</span><span class="p">.</span><span class="nf">root</span><span class="si">}</span><span class="s2">/app/overrides/**/*_override.rb"</span><span class="p">).</span><span class="nf">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">override</span><span class="o">|</span>
        <span class="n">require_dependency</span> <span class="n">override</span>
      <span class="k">end</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre>
<button class="clipboard-button" data-clipboard-text='# 設定/應用程式.rb
module MyApp
  class Application &lt; Rails::Application
    # ...

    config.to_prepare do
      Dir.glob("#{Rails.root}/app/overrides/**/*_override.rb").each do |override|
        require_dependency override
      end
    end
  end
end
'>Copy</button>
</div>
<h5 id="class-eval"><a class="anchorlink" href="#class-eval">6.1.1 使用 <code>class_eval</code> 重新開啟現有類</a></h5><p>例如，為了覆蓋引擎 model</p><div class="code_container">
<pre><code class="highlight ruby"><span class="c1"># Blorgh/app/models/blorgh/article.rb</span>
<span class="k">module</span> <span class="nn">Blorgh</span>
  <span class="k">class</span> <span class="nc">Article</span> <span class="o">&lt;</span> <span class="no">ApplicationRecord</span>
    <span class="n">has_many</span> <span class="ss">:comments</span>

    <span class="k">def</span> <span class="nf">summary</span>
      <span class="s2">"</span><span class="si">#{</span><span class="n">title</span><span class="si">}</span><span class="s2">"</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre>
<button class="clipboard-button" data-clipboard-text='# Blorgh/app/models/blorgh/article.rb
module Blorgh
  class Article &lt; ApplicationRecord
    has_many :comments

    def summary
      "#{title}"
    end
  end
end
'>Copy</button>
</div>
<p>您只需建立一個<em>reopens</em>該類的檔案：</p><div class="code_container">
<pre><code class="highlight ruby"><span class="c1"># MyApp/app/overrides/models/blorgh/article_override.rb</span>
<span class="no">Blorgh</span><span class="o">::</span><span class="no">Article</span><span class="p">.</span><span class="nf">class_eval</span> <span class="k">do</span>
  <span class="k">def</span> <span class="nf">time_since_created</span>
    <span class="no">Time</span><span class="p">.</span><span class="nf">current</span> <span class="o">-</span> <span class="n">created_at</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">summary</span>
    <span class="s2">"</span><span class="si">#{</span><span class="n">title</span><span class="si">}</span><span class="s2"> - </span><span class="si">#{</span><span class="n">truncate</span><span class="p">(</span><span class="n">text</span><span class="p">)</span><span class="si">}</span><span class="s2">"</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre>
<button class="clipboard-button" data-clipboard-text='# MyApp/app/overrides/models/blorgh/article_override.rb
Blorgh::Article.class_eval do
  def time_since_created
    Time.current - created_at
  end

  def summary
    "#{title} - #{truncate(text)}"
  end
end
'>Copy</button>
</div>
<p>覆蓋 <em>reopens</em> 類或 module 非常重要。如果它們不在記憶體中，則使用 <code>class</code> 或 <code>module</code> keywords 將定義它們，這將是不正確的，因為定義存在於引擎中。使用如上所示的 <code>class_eval</code> 可確保您重新開啟。</p><h5 id="activesupport-concern"><a class="anchorlink" href="#activesupport-concern">6.1.2 使用 ActiveSupport::Concern 重新開啟現有類</a></h5><p>使用 <code>Class#class_eval</code> 非常適合簡單的調整，但對於更復雜的
類修改，您可能需要考慮使用 <a href="https://api.rubyonrails.org/v7.0.0/classes/ActiveSupport/Concern.html"><code>ActiveSupport::Concern</code></a>。
ActiveSupport::Concern 管理相互關聯的依賴 modules 和的載入順序
執行時的類允許您顯著模組化您的程式碼。</p><p><strong>新增</strong> <code>Article#time_since_created</code> 和<strong>覆蓋</strong> <code>Article#summary</code>：</p><div class="code_container">
<pre><code class="highlight ruby"><span class="c1"># MyApp/app/models/blorgh/article.rb</span>

<span class="k">class</span> <span class="nc">Blorgh::Article</span> <span class="o">&lt;</span> <span class="no">ApplicationRecord</span>
  <span class="kp">include</span> <span class="no">Blorgh</span><span class="o">::</span><span class="no">Concerns</span><span class="o">::</span><span class="no">Models</span><span class="o">::</span><span class="no">Article</span>

  <span class="k">def</span> <span class="nf">time_since_created</span>
    <span class="no">Time</span><span class="p">.</span><span class="nf">current</span> <span class="o">-</span> <span class="n">created_at</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">summary</span>
    <span class="s2">"</span><span class="si">#{</span><span class="n">title</span><span class="si">}</span><span class="s2"> - </span><span class="si">#{</span><span class="n">truncate</span><span class="p">(</span><span class="n">text</span><span class="p">)</span><span class="si">}</span><span class="s2">"</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre>
<button class="clipboard-button" data-clipboard-text='# MyApp/app/models/blorgh/article.rb

class Blorgh::Article &lt; ApplicationRecord
  include Blorgh::Concerns::Models::Article

  def time_since_created
    Time.current - created_at
  end

  def summary
    "#{title} - #{truncate(text)}"
  end
end
'>Copy</button>
</div>
<div class="code_container">
<pre><code class="highlight ruby"><span class="c1"># Blorgh/app/models/blorgh/article.rb</span>
<span class="k">module</span> <span class="nn">Blorgh</span>
  <span class="k">class</span> <span class="nc">Article</span> <span class="o">&lt;</span> <span class="no">ApplicationRecord</span>
    <span class="kp">include</span> <span class="no">Blorgh</span><span class="o">::</span><span class="no">Concerns</span><span class="o">::</span><span class="no">Models</span><span class="o">::</span><span class="no">Article</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre>
<button class="clipboard-button" data-clipboard-text="# Blorgh/app/models/blorgh/article.rb
module Blorgh
  class Article &lt; ApplicationRecord
    include Blorgh::Concerns::Models::Article
  end
end
">Copy</button>
</div>
<div class="code_container">
<pre><code class="highlight ruby"><span class="c1"># Blorgh/lib/concerns/models/article.rb</span>

<span class="k">module</span> <span class="nn">Blorgh::Concerns::Models::Article</span>
  <span class="kp">extend</span> <span class="no">ActiveSupport</span><span class="o">::</span><span class="no">Concern</span>

  <span class="c1"># 'included do' causes the included code to be evaluated in the</span>
  <span class="c1"># context where it is included (article.rb), rather than being</span>
  <span class="c1"># executed in the module's context (blorgh/concerns/models/article).</span>
  <span class="n">included</span> <span class="k">do</span>
    <span class="nb">attr_accessor</span> <span class="ss">:author_name</span>
    <span class="n">belongs_to</span> <span class="ss">:author</span><span class="p">,</span> <span class="ss">class_name: </span><span class="s2">"User"</span>

    <span class="n">before_validation</span> <span class="ss">:set_author</span>

    <span class="kp">private</span>
      <span class="k">def</span> <span class="nf">set_author</span>
        <span class="nb">self</span><span class="p">.</span><span class="nf">author</span> <span class="o">=</span> <span class="no">User</span><span class="p">.</span><span class="nf">find_or_create_by</span><span class="p">(</span><span class="ss">name: </span><span class="n">author_name</span><span class="p">)</span>
      <span class="k">end</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">summary</span>
    <span class="s2">"</span><span class="si">#{</span><span class="n">title</span><span class="si">}</span><span class="s2">"</span>
  <span class="k">end</span>

  <span class="k">module</span> <span class="nn">ClassMethods</span>
    <span class="k">def</span> <span class="nf">some_class_method</span>
      <span class="s1">'some class method string'</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre>
<button class="clipboard-button" data-clipboard-text="# Blorgh/lib/concerns/models/article.rb

module Blorgh::Concerns::Models::Article
  extend ActiveSupport::Concern

  # 'included do' causes the included code to be evaluated in the
  # context where it is included (article.rb), rather than being
  # executed in the module's context (blorgh/concerns/models/article).
  included do
    attr_accessor :author_name
    belongs_to :author, class_name: &quot;User&quot;

    before_validation :set_author

    private
      def set_author
        self.author = User.find_or_create_by(name: author_name)
      end
  end

  def summary
    &quot;#{title}&quot;
  end

  module ClassMethods
    def some_class_method
      'some class method string'
    end
  end
end
">Copy</button>
</div>
<h4 id=""><a class="anchorlink" href="#">6.2 自動載入和引擎</a></h4><p>請檢查<a href="autoloading_and_reloading_constants.html#autoloading-and-engines">自動載入和重新載入常量</a>
有關自動載入和引擎的更多資訊的指南。</p><h4 id="views"><a class="anchorlink" href="#views">6.3 覆蓋 Views</a></h4><p>當 Rails 尋找一個 view 進行渲染時，它會首先在 <code>app/views</code> 中尋找
應用程式的目錄。如果在那裡找不到 view，它會簽入
具有此目錄的所有引擎的 <code>app/views</code> 目錄。</p><p>當應用程式被要求為 <code>Blorgh::ArticlesController</code> 渲染 view 時
index action，它會先尋找路徑
應用程式中的 <code>app/views/blorgh/articles/index.html.erb</code>。如果不能
找到它，它將檢視引擎內部。</p><p>您可以在應用程式中通過簡單地在以下位置建立一個新檔案來覆蓋此 view
<code>app/views/blorgh/articles/index.html.erb</code>。然後你可以完全改變什麼
這個 view 通常會輸出。</p><p>現在通過在 <code>app/views/blorgh/articles/index.html.erb</code> 建立一個新檔案來嘗試這個
並將此內容放入其中：</p><div class="code_container">
<pre><code class="highlight erb"><span class="nt">&lt;h1&gt;</span>Articles<span class="nt">&lt;/h1&gt;</span>
<span class="cp">&lt;%=</span> <span class="n">link_to</span> <span class="s2">"New Article"</span><span class="p">,</span> <span class="n">new_article_path</span> <span class="cp">%&gt;</span>
<span class="cp">&lt;%</span> <span class="vi">@articles</span><span class="p">.</span><span class="nf">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">article</span><span class="o">|</span> <span class="cp">%&gt;</span>
  <span class="nt">&lt;h2&gt;</span><span class="cp">&lt;%=</span> <span class="n">article</span><span class="p">.</span><span class="nf">title</span> <span class="cp">%&gt;</span><span class="nt">&lt;/h2&gt;</span>
  <span class="nt">&lt;small&gt;</span>By <span class="cp">&lt;%=</span> <span class="n">article</span><span class="p">.</span><span class="nf">author</span> <span class="cp">%&gt;</span><span class="nt">&lt;/small&gt;</span>
  <span class="cp">&lt;%=</span> <span class="n">simple_format</span><span class="p">(</span><span class="n">article</span><span class="p">.</span><span class="nf">text</span><span class="p">)</span> <span class="cp">%&gt;</span>
  <span class="nt">&lt;hr&gt;</span>
<span class="cp">&lt;%</span> <span class="k">end</span> <span class="cp">%&gt;</span>
</code></pre>
<button class="clipboard-button" data-clipboard-text='&lt;h1&gt;Articles&lt;/h1&gt;
&lt;%= link_to "New Article", new_article_path %&gt;
&lt;% @articles.each do |article| %&gt;
  &lt;h2&gt;&lt;%= article.title %&gt;&lt;/h2&gt;
  &lt;small&gt;By &lt;%= article.author %&gt;&lt;/small&gt;
  &lt;%= simple_format(article.text) %&gt;
  &lt;hr&gt;
&lt;% end %&gt;
'>Copy</button>
</div>
<h4 id=""><a class="anchorlink" href="#">6.4 路線</a></h4><p>預設情況下，引擎內的路由與應用程式隔離。這是
由 <code>Engine</code> 類中的 <code>isolate_namespace</code> 呼叫完成。這本質上
意味著應用程式及其引擎可以具有相同命名的路由和
他們不會發生衝突。</p><p>引擎內的路線繪製在 <code>Engine</code> 類上
<code>config/routes.rb</code>，像這樣：</p><div class="code_container">
<pre><code class="highlight ruby"><span class="no">Blorgh</span><span class="o">::</span><span class="no">Engine</span><span class="p">.</span><span class="nf">routes</span><span class="p">.</span><span class="nf">draw</span> <span class="k">do</span>
  <span class="n">resources</span> <span class="ss">:articles</span>
<span class="k">end</span>
</code></pre>
<button class="clipboard-button" data-clipboard-text="Blorgh::Engine.routes.draw do
  resources :articles
end
">Copy</button>
</div>
<p>通過擁有這樣的隔離路線，如果您希望連結到某個區域
應用程式中的引擎，您將需要使用引擎的路由
代理方式。呼叫正常的路由方法如 <code>articles_path</code> 可能會結束
如果應用程式和引擎都有這樣的
helper 已定義。</p><p>例如，以下示例將轉到應用程式的 <code>articles_path</code>
如果該模板是從應用程式渲染的，或者引擎的 <code>articles_path</code>
如果它是從引擎渲染的：</p><div class="code_container">
<pre><code class="highlight erb"><span class="cp">&lt;%=</span> <span class="n">link_to</span> <span class="s2">"Blog articles"</span><span class="p">,</span> <span class="n">articles_path</span> <span class="cp">%&gt;</span>
</code></pre>
<button class="clipboard-button" data-clipboard-text='&lt;%= link_to "Blog articles", articles_path %&gt;
'>Copy</button>
</div>
<p>要使這條路線始終使用引擎的 <code>articles_path</code> 路由 helper 方法，
我們必須呼叫與路由代理方法同名的方法
引擎。</p><div class="code_container">
<pre><code class="highlight erb"><span class="cp">&lt;%=</span> <span class="n">link_to</span> <span class="s2">"Blog articles"</span><span class="p">,</span> <span class="n">blorgh</span><span class="p">.</span><span class="nf">articles_path</span> <span class="cp">%&gt;</span>
</code></pre>
<button class="clipboard-button" data-clipboard-text='&lt;%= link_to "Blog articles", blorgh.articles_path %&gt;
'>Copy</button>
</div>
<p>如果您希望以類似方式引用引擎內部的應用程式，請使用
<code>main_app</code> helper：</p><div class="code_container">
<pre><code class="highlight erb"><span class="cp">&lt;%=</span> <span class="n">link_to</span> <span class="s2">"Home"</span><span class="p">,</span> <span class="n">main_app</span><span class="p">.</span><span class="nf">root_path</span> <span class="cp">%&gt;</span>
</code></pre>
<button class="clipboard-button" data-clipboard-text='&lt;%= link_to "Home", main_app.root_path %&gt;
'>Copy</button>
</div>
<p>如果你在引擎中使用它，它會<strong>總是</strong>轉到
應用程式的根。如果您不使用 <code>main_app</code>“路由代理”
方法呼叫，它可能會轉到引擎或應用程式的根目錄，
取決於它是從哪裡呼叫的。</p><p>如果從引擎內部呈現的模板嘗試使用
應用程式的路由 helper 方法，它可能會導致未定義的方法呼叫。
如果您遇到這樣的問題，請確保您沒有嘗試呼叫
不帶 <code>main_app</code> 字首的應用程式路由方法
引擎。</p><h4 id=""><a class="anchorlink" href="#">6.5 資產</a></h4><p>引擎中的資產以與完整應用程式相同的方式工作。因為
引擎類繼承自 <code>Rails::Engine</code>，應用程式將知道
在引擎的 <code>app/assets</code> 和 <code>lib/assets</code> 目錄中查詢資產。</p><p>與引擎的所有其他元件一樣，資產應該是名稱空間的。
這意味著如果你有一個名為 <code>style.css</code> 的資產，它應該放在
<code>app/assets/stylesheets/[engine name]/style.css</code>，而不是
<code>app/assets/stylesheets/style.css</code>。如果此資產沒有名稱空間，則有一個
主機應用程式可能具有相同命名的資產，在
在這種情況下，應用程式的資產優先，引擎的資產優先
將被忽略。</p><p>想象一下，你確實有一個資產位於
<code>app/assets/stylesheets/blorgh/style.css</code>。將此資產包含在
應用程式，只需使用 <code>stylesheet_link_tag</code> 並引用資產就好像它
在發動機內：</p><div class="code_container">
<pre><code class="highlight erb"><span class="cp">&lt;%=</span> <span class="n">stylesheet_link_tag</span> <span class="s2">"blorgh/style.css"</span> <span class="cp">%&gt;</span>
</code></pre>
<button class="clipboard-button" data-clipboard-text='&lt;%= stylesheet_link_tag "blorgh/style.css" %&gt;
'>Copy</button>
</div>
<p>您還可以使用 Asset 將這些資產指定為其他資產的依賴項
管道處理檔案中的 require 語句：</p><div class="code_container">
<pre><code class="highlight css"><span class="c">/*
 *= require blorgh/style
 */</span>
</code></pre>
<button class="clipboard-button" data-clipboard-text="/*
 *= require blorgh/style
 */
">Copy</button>
</div>
<p>資訊。記住，為了使用像 Sass 或 CoffeeScript 這樣的語言，你
應該將相關庫新增到您引擎的 <code>.gemspec</code>。</p><h4 id=""><a class="anchorlink" href="#">6.6 分離資產和預編譯</a></h4><p>在某些情況下，引擎不需要您的引擎資產
主機應用程式。例如，假設您已經建立了一個管理功能
只存在於您的引擎。在這種情況下，宿主應用程式不會
需要要求 <code>admin.css</code> 或 <code>admin.js</code>。只有 gem 的管理佈局需要
這些資產。主機應用程式包含沒有意義
<code>"blorgh/admin.css"</code> 在其樣式表中。在這種情況下，你應該
為預編譯明確定義這些資產。這告訴鏈輪新增
觸發 <code>bin/rails assets:precompile</code> 時的引擎資產。</p><p>您可以在 <code>engine.rb</code> 中定義用於預編譯的資產：</p><div class="code_container">
<pre><code class="highlight ruby"><span class="n">initializer</span> <span class="s2">"blorgh.assets.precompile"</span> <span class="k">do</span> <span class="o">|</span><span class="n">app</span><span class="o">|</span>
  <span class="n">app</span><span class="p">.</span><span class="nf">config</span><span class="p">.</span><span class="nf">assets</span><span class="p">.</span><span class="nf">precompile</span> <span class="o">+=</span> <span class="sx">%w( admin.js admin.css )</span>
<span class="k">end</span>
</code></pre>
<button class="clipboard-button" data-clipboard-text='initializer "blorgh.assets.precompile" do |app|
  app.config.assets.precompile += %w( admin.js admin.css )
end
'>Copy</button>
</div>
<p>有關更多資訊，請閱讀 <a href="asset_pipeline.html">Asset Pipeline 指南</a>。</p><h4 id="gem"><a class="anchorlink" href="#gem">6.7 其他 Gem 依賴</a></h4><p>引擎內的 Gem 依賴項應該在 <code>.gemspec</code> 檔案中指定
在引擎的根部。原因是發動機可能安裝為
寶石。如果要在 <code>Gemfile</code> 中指定依賴項，這些將不會
被傳統的 gem 安裝識別，所以它們不會被安裝，
導致發動機故障。</p><p>指定應在執行期間與引擎一起安裝的依賴項
傳統的 <code>gem install</code>，在 <code>Gem::Specification</code> 塊內指定
在引擎中的 <code>.gemspec</code> 檔案中：</p><div class="code_container">
<pre><code class="highlight ruby"><span class="n">s</span><span class="p">.</span><span class="nf">add_dependency</span> <span class="s2">"moo"</span>
</code></pre>
<button class="clipboard-button" data-clipboard-text='s.add_dependency "moo"
'>Copy</button>
</div>
<p>指定僅應作為開發安裝的依賴項
應用程式的依賴項，像這樣指定它：</p><div class="code_container">
<pre><code class="highlight ruby"><span class="n">s</span><span class="p">.</span><span class="nf">add_development_dependency</span> <span class="s2">"moo"</span>
</code></pre>
<button class="clipboard-button" data-clipboard-text='s.add_development_dependency "moo"
'>Copy</button>
</div>
<p>兩種依賴都會在裡面執行 <code>bundle install</code> 時安裝
的應用程式。將僅使用 gem 的開發依賴項
當發動機的開發和測試正在進行時。</p><p>請注意，如果您想在引擎啟動時立即要求依賴
需要，您應該在引擎初始化之前要求它們。為了
例子：</p><div class="code_container">
<pre><code class="highlight ruby"><span class="nb">require</span> <span class="s2">"other_engine/engine"</span>
<span class="nb">require</span> <span class="s2">"yet_another_engine/engine"</span>

<span class="k">module</span> <span class="nn">MyEngine</span>
  <span class="k">class</span> <span class="nc">Engine</span> <span class="o">&lt;</span> <span class="o">::</span><span class="no">Rails</span><span class="o">::</span><span class="no">Engine</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre>
<button class="clipboard-button" data-clipboard-text='require "other_engine/engine"
require "yet_another_engine/engine"

module MyEngine
  class Engine &lt; ::Rails::Engine
  end
end
'>Copy</button>
</div>
<h3 id=""><a class="anchorlink" href="#">7 載入和設定掛鉤</a></h3><p>Rails 程式碼通常可以在載入應用程式時引用。 Rails 負責這些框架的載入順序，因此當您載入框架（例如 <code>ActiveRecord::Base</code>）時，您過早地違反了您的應用程式與 Rails 的隱式合同。此外，通過在應用程式啟動時載入諸如 <code>ActiveRecord::Base</code> 之類的程式碼，您正在載入整個框架，這可能會減慢啟動時間，並可能導致與應用程式的載入順序和啟動衝突。</p><p>載入和設定掛鉤是允許您在不違反與 Rails 的載入合同的情況下掛鉤到此初始化過程的 API。這也將緩解引導效能下降並避免衝突。</p><h4 id="rails"><a class="anchorlink" href="#rails">7.1 避免載入 Rails 框架</a></h4><p>由於Ruby是動態語言，所以有些程式碼會導致載入不同的Rails框架。以這個片段為例：</p><div class="code_container">
<pre><code class="highlight ruby"><span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span><span class="p">.</span><span class="nf">include</span><span class="p">(</span><span class="no">MyActiveRecordHelper</span><span class="p">)</span>
</code></pre>
<button class="clipboard-button" data-clipboard-text="ActiveRecord::Base.include(MyActiveRecordHelper)
">Copy</button>
</div>
<p>這段程式碼意味著當這個檔案被載入時，它會遇到<code>ActiveRecord::Base</code>。這次遇到導致 Ruby 查詢該常量的定義並需要它。這會導致在啟動時載入整個 Active Record 框架。</p><p><code>ActiveSupport.on_load</code> 是一種機制，可用於將程式碼的載入推遲到實際需要時。上面的程式碼片段可以更改為：</p><div class="code_container">
<pre><code class="highlight ruby"><span class="no">ActiveSupport</span><span class="p">.</span><span class="nf">on_load</span><span class="p">(</span><span class="ss">:active_record</span><span class="p">)</span> <span class="k">do</span>
  <span class="kp">include</span> <span class="no">MyActiveRecordHelper</span>
<span class="k">end</span>
</code></pre>
<button class="clipboard-button" data-clipboard-text="ActiveSupport.on_load(:active_record) do
  include MyActiveRecordHelper
end
">Copy</button>
</div>
<p>當載入 <code>ActiveRecord::Base</code> 時，此新程式碼段將僅包含 <code>MyActiveRecordHelper</code>。</p><h4 id="hooks"><a class="anchorlink" href="#hooks">7.2 什麼時候呼叫 Hooks？</a></h4><p>在 Rails 框架中，當載入特定庫時會呼叫這些掛載機制。例如，當載入 <code>ActionController::Base</code> 時，會呼叫 <code>:action_controller_base</code> 掛載機制。這意味著所有帶有 <code>:action_controller_base</code> 掛載機制的 <code>ActiveSupport.on_load</code> 呼叫都將在 <code>ActionController::Base</code> 的上下文中被呼叫（這意味著 <code>self</code> 將是一個 <code>ActionController::Base</code>）。</p><h4 id="load-hooks"><a class="anchorlink" href="#load-hooks">7.3 修改程式碼使用Load Hooks</a></h4><p>修改程式碼通常很簡單。如果您有一行程式碼引用了 Rails 框架，例如 <code>ActiveRecord::Base</code>，您可以將該程式碼包裝在載入掛鉤中。</p><p><strong>修改對 <code>include</code> 的呼叫</strong></p><div class="code_container">
<pre><code class="highlight ruby"><span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span><span class="p">.</span><span class="nf">include</span><span class="p">(</span><span class="no">MyActiveRecordHelper</span><span class="p">)</span>
</code></pre>
<button class="clipboard-button" data-clipboard-text="ActiveRecord::Base.include(MyActiveRecordHelper)
">Copy</button>
</div>
<p>變成</p><div class="code_container">
<pre><code class="highlight ruby"><span class="no">ActiveSupport</span><span class="p">.</span><span class="nf">on_load</span><span class="p">(</span><span class="ss">:active_record</span><span class="p">)</span> <span class="k">do</span>
  <span class="c1"># self refers to ActiveRecord::Base here,</span>
  <span class="c1"># so we can call .include</span>
  <span class="kp">include</span> <span class="no">MyActiveRecordHelper</span>
<span class="k">end</span>
</code></pre>
<button class="clipboard-button" data-clipboard-text="ActiveSupport.on_load(:active_record) do
  # self refers to ActiveRecord::Base here,
  # so we can call .include
  include MyActiveRecordHelper
end
">Copy</button>
</div>
<p><strong>修改對 <code>prepend</code> 的呼叫</strong></p><div class="code_container">
<pre><code class="highlight ruby"><span class="no">ActionController</span><span class="o">::</span><span class="no">Base</span><span class="p">.</span><span class="nf">prepend</span><span class="p">(</span><span class="no">MyActionControllerHelper</span><span class="p">)</span>
</code></pre>
<button class="clipboard-button" data-clipboard-text="ActionController::Base.prepend(MyActionControllerHelper)
">Copy</button>
</div>
<p>變成</p><div class="code_container">
<pre><code class="highlight ruby"><span class="no">ActiveSupport</span><span class="p">.</span><span class="nf">on_load</span><span class="p">(</span><span class="ss">:action_controller_base</span><span class="p">)</span> <span class="k">do</span>
  <span class="c1"># self refers to ActionController::Base here,</span>
  <span class="c1"># so we can call .prepend</span>
  <span class="n">prepend</span> <span class="no">MyActionControllerHelper</span>
<span class="k">end</span>
</code></pre>
<button class="clipboard-button" data-clipboard-text="ActiveSupport.on_load(:action_controller_base) do
  # self refers to ActionController::Base here,
  # so we can call .prepend
  prepend MyActionControllerHelper
end
">Copy</button>
</div>
<p><strong>修改對類方法的呼叫</strong></p><div class="code_container">
<pre><code class="highlight ruby"><span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span><span class="p">.</span><span class="nf">include_root_in_json</span> <span class="o">=</span> <span class="kp">true</span>
</code></pre>
<button class="clipboard-button" data-clipboard-text="ActiveRecord::Base.include_root_in_json = true
">Copy</button>
</div>
<p>變成</p><div class="code_container">
<pre><code class="highlight ruby"><span class="no">ActiveSupport</span><span class="p">.</span><span class="nf">on_load</span><span class="p">(</span><span class="ss">:active_record</span><span class="p">)</span> <span class="k">do</span>
  <span class="c1"># self refers to ActiveRecord::Base here</span>
  <span class="nb">self</span><span class="p">.</span><span class="nf">include_root_in_json</span> <span class="o">=</span> <span class="kp">true</span>
<span class="k">end</span>
</code></pre>
<button class="clipboard-button" data-clipboard-text="ActiveSupport.on_load(:active_record) do
  # self refers to ActiveRecord::Base here
  self.include_root_in_json = true
end
">Copy</button>
</div>
<h4 id=""><a class="anchorlink" href="#">7.4 可用的負載掛鉤</a></h4><p>這些是您可以在自己的程式碼中使用的載入掛鉤。要掛鉤以下類之一的初始化過程，請使用可用掛鉤。</p>
<table>
<thead>
<tr>
<th>班級</th>
<th>鉤</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>ActionCable</code></td>
<td><code>action_cable</code></td>
</tr>
<tr>
<td><code>ActionCable::Channel::Base</code></td>
<td><code>action_cable_channel</code></td>
</tr>
<tr>
<td><code>ActionCable::Connection::Base</code></td>
<td><code>action_cable_connection</code></td>
</tr>
<tr>
<td><code>ActionCable::Connection::TestCase</code></td>
<td><code>action_cable_connection_test_case</code></td>
</tr>
<tr>
<td><code>ActionController::API</code></td>
<td><code>action_controller_api</code></td>
</tr>
<tr>
<td><code>ActionController::API</code></td>
<td><code>action_controller</code></td>
</tr>
<tr>
<td><code>ActionController::Base</code></td>
<td><code>action_controller_base</code></td>
</tr>
<tr>
<td><code>ActionController::Base</code></td>
<td><code>action_controller</code></td>
</tr>
<tr>
<td><code>ActionController::TestCase</code></td>
<td><code>action_controller_test_case</code></td>
</tr>
<tr>
<td><code>ActionDispatch::IntegrationTest</code></td>
<td><code>action_dispatch_integration_test</code></td>
</tr>
<tr>
<td><code>ActionDispatch::Response</code></td>
<td><code>action_dispatch_response</code></td>
</tr>
<tr>
<td><code>ActionDispatch::Request</code></td>
<td><code>action_dispatch_request</code></td>
</tr>
<tr>
<td><code>ActionDispatch::SystemTestCase</code></td>
<td><code>action_dispatch_system_test_case</code></td>
</tr>
<tr>
<td><code>ActionMailbox::Base</code></td>
<td><code>action_mailbox</code></td>
</tr>
<tr>
<td><code>ActionMailbox::InboundEmail</code></td>
<td><code>action_mailbox_inbound_email</code></td>
</tr>
<tr>
<td><code>ActionMailbox::Record</code></td>
<td><code>action_mailbox_record</code></td>
</tr>
<tr>
<td><code>ActionMailbox::TestCase</code></td>
<td><code>action_mailbox_test_case</code></td>
</tr>
<tr>
<td><code>ActionMailer::Base</code></td>
<td><code>action_mailer</code></td>
</tr>
<tr>
<td><code>ActionMailer::TestCase</code></td>
<td><code>action_mailer_test_case</code></td>
</tr>
<tr>
<td><code>ActionText::Content</code></td>
<td><code>action_text_content</code></td>
</tr>
<tr>
<td><code>ActionText::Record</code></td>
<td><code>action_text_record</code></td>
</tr>
<tr>
<td><code>ActionText::RichText</code></td>
<td><code>action_text_rich_text</code></td>
</tr>
<tr>
<td><code>ActionView::Base</code></td>
<td><code>action_view</code></td>
</tr>
<tr>
<td><code>ActionView::TestCase</code></td>
<td><code>action_view_test_case</code></td>
</tr>
<tr>
<td><code>ActiveJob::Base</code></td>
<td><code>active_job</code></td>
</tr>
<tr>
<td><code>ActiveJob::TestCase</code></td>
<td><code>active_job_test_case</code></td>
</tr>
<tr>
<td><code>ActiveRecord::Base</code></td>
<td><code>active_record</code></td>
</tr>
<tr>
<td><code>ActiveStorage::Attachment</code></td>
<td><code>active_storage_attachment</code></td>
</tr>
<tr>
<td><code>ActiveStorage::VariantRecord</code></td>
<td><code>active_storage_variant_record</code></td>
</tr>
<tr>
<td><code>ActiveStorage::Blob</code></td>
<td><code>active_storage_blob</code></td>
</tr>
<tr>
<td><code>ActiveStorage::Record</code></td>
<td><code>active_storage_record</code></td>
</tr>
<tr>
<td><code>ActiveSupport::TestCase</code></td>
<td><code>active_support_test_case</code></td>
</tr>
<tr>
<td><code>i18n</code></td>
<td><code>i18n</code></td>
</tr>
</tbody>
</table>
<h4 id=""><a class="anchorlink" href="#">7.5 可用的設定掛載機制</a></h4><p>設定掛鉤不掛鉤到任何特定框架，而是在整個應用程式的上下文中執行。</p>
<table>
<thead>
<tr>
<th>鉤</th>
<th>用例</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>before_configuration</code></td>
<td>要執行的第一個可設定塊。在執行任何初始化程式之前呼叫。</td>
</tr>
<tr>
<td><code>before_initialize</code></td>
<td>要執行的第二個可設定塊。在框架初始化之前呼叫。</td>
</tr>
<tr>
<td><code>before_eager_load</code></td>
<td>要執行的第三個可設定塊。如果 <code>config.eager_load</code> 設定為 false，則不執行。</td>
</tr>
<tr>
<td><code>after_initialize</code></td>
<td>要執行的最後一個可設定塊。在框架初始化後呼叫。</td>
</tr>
</tbody>
</table>
<p>可以在 Engine 類中呼叫設定掛鉤。</p><div class="code_container">
<pre><code class="highlight ruby"><span class="k">module</span> <span class="nn">Blorgh</span>
  <span class="k">class</span> <span class="nc">Engine</span> <span class="o">&lt;</span> <span class="o">::</span><span class="no">Rails</span><span class="o">::</span><span class="no">Engine</span>
    <span class="n">config</span><span class="p">.</span><span class="nf">before_configuration</span> <span class="k">do</span>
      <span class="nb">puts</span> <span class="s1">'I am called before any initializers'</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre>
<button class="clipboard-button" data-clipboard-text="module Blorgh
  class Engine &lt; ::Rails::Engine
    config.before_configuration do
      puts 'I am called before any initializers'
    end
  end
end
">Copy</button>
</div>


        <h3>回饋</h3>
        <p>
          我們鼓勵您幫助提高本指南的品質。
        </p>
        <p>
          如果您發現任何拼寫錯誤或資訊錯誤，請提供回饋。
          要開始回饋，您可以閱讀我們的 <a href="https://edgeguides.rubyonrails.org/contributing_to_ruby_on_rails.html#contributing-to-the-rails-documentation">回饋</a> 部分。
        </p>
        <p>
          您還可能會發現不完整的內容或不是最新的內容。
          請務必為 main 新增任何遺漏的文件。假設是
          <a href="https://edgeguides.rubyonrails.org">非穩定版指南(edge guides)</a> 請先驗證問題是否已經在主分支上解決。
          請前往 <a href="ruby_on_rails_guides_guidelines.html">Ruby on Rails 指南寫作準則</a> 查看寫作風格和慣例。
        </p>
        <p>
          如果由於某種原因您發現要修復的內容但無法自行修補，請您 <a href="https://github.com/rails/rails/issues">提出 issue</a>。
        </p>
        <p>關於 Ruby on Rails 的任何類型的討論歡迎提供任何文件至 <a href="https://discuss.rubyonrails.org/c/rubyonrails-docs">rubyonrails-docs 討論區</a>。
        </p>
      </div>
    </div>
  </div>

  <hr class="hide" />
  <div id="footer">
    <div class="wrapper">
      <p>本作品已獲得<a href="https://creativecommons.org/licenses/by-sa/4.0/">知識共享署名-相同方式共享 4.0 國際</a>許可</p>
<p>“Rails”、“Ruby on Rails”和 Rails 標誌是 David Heinemeier Hansson 的商標。 保留所有權利。</p>
    </div>
  </div>
</body>
</html>
