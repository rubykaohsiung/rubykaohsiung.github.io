<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>使用 Rails 快取：結束view — Ruby on Rails Guides</title>
  <link rel="stylesheet" type="text/css" href="stylesheets/style.css" data-turbolinks-track="reload">
  <link rel="stylesheet" type="text/css" href="stylesheets/print.css" media="print">
  <link rel="stylesheet" type="text/css" href="stylesheets/highlight.css" data-turbolinks-track="reload">
  <link href="images/favicon.ico" rel="shortcut icon" type="image/x-icon" />
  <script src="javascripts/turbolinks.js" data-turbolinks-track="reload"></script>
  <script src="javascripts/clipboard.js" data-turbolinks-track="reload"></script>
  <script src="javascripts/guides.js" data-turbolinks-track="reload"></script>
  <meta property="og:title" content="使用 Rails 快取：結束view — Ruby on Rails Guides" />
  <meta name="description" content="請勿在 GITHUB 上閱讀此檔案，指南釋出在 https://guides.rubyonrails.org.使用 Rails 快取：結束view本指南介紹瞭如何使用快取加速 Rails 應用程式。快取意味著儲存在請求-響應週期中生成的內容和 在響應類似請求時重用它。快取通常是提高應用程式效能的最有效方法。 透過快取，網站在具有單個數據庫的單個伺服器上執行 可以承受數千個併發使用者的負載。Rails 提供了一組開箱即用的快取功能。本指南將教 您瞭解其中每一項的範圍和目的。掌握這些技巧和你的 Rails 應用程式可以為數以百萬計的views 提供服務，而不會產生過多的響應時間 或伺服器賬單。閱讀本指南後，您將瞭解： 片段和俄羅斯娃娃快取。 如何管理快取依賴。 替代快取儲存。 有條件的 GET 支援。" />
  <meta property="og:description" content="請勿在 GITHUB 上閱讀此檔案，指南釋出在 https://guides.rubyonrails.org.使用 Rails 快取：結束view本指南介紹瞭如何使用快取加速 Rails 應用程式。快取意味著儲存在請求-響應週期中生成的內容和 在響應類似請求時重用它。快取通常是提高應用程式效能的最有效方法。 透過快取，網站在具有單個數據庫的單個伺服器上執行 可以承受數千個併發使用者的負載。Rails 提供了一組開箱即用的快取功能。本指南將教 您瞭解其中每一項的範圍和目的。掌握這些技巧和你的 Rails 應用程式可以為數以百萬計的views 提供服務，而不會產生過多的響應時間 或伺服器賬單。閱讀本指南後，您將瞭解： 片段和俄羅斯娃娃快取。 如何管理快取依賴。 替代快取儲存。 有條件的 GET 支援。" />
  <meta property="og:locale" content="en_US" />
  <meta property="og:site_name" content="Ruby on Rails Guides" />
  <meta property="og:image" content="https://avatars.githubusercontent.com/u/4223" />
  <meta property="og:type" content="website" />
</head>
<body class="guide">
  <div>
    <div id="version-badge">v6.1.4</div>
  </div>
  <div id="topNav">
    <div class="wrapper">
      <strong class="more-info-label">更多訊息請訪問 <a href="https://rubyonrails.org/">rubyonrails.org：</a> </strong>
      <span class="red-button more-info-button">
        更多 Ruby on Rails
      </span>
      <ul class="more-info-links s-hidden">
        <li class="more-info"><a href="https://weblog.rubyonrails.org/">部落格</a></li>
        <li class="more-info"><a href="https://guides.rubyonrails.org/">指南</a></li>
        <li class="more-info"><a href="https://api.rubyonrails.org/">API</a></li>
        <li class="more-info"><a href="https://discuss.rubyonrails.org/">論壇</a></li>
        <li class="more-info"><a href="https://github.com/rails/rails">在 GitHub 上做出貢獻</a></li>
      </ul>
    </div>
  </div>
  <div id="header">
    <div class="wrapper clearfix">
      <h1><a href="index.html" title="返回首頁">Guides.rubyonrails.org</a></h1>
      <ul class="nav">
        <li><a class="nav-item" href="index.html">首頁</a></li>
        <li class="guides-index guides-index-large">
          <a href="index.html" id="guidesMenu" class="guides-index-item nav-item">指南索引</a>
          <div id="guides" class="clearfix" style="display: none;">
            <hr />
            <dl class="guides-section-container">
                <div class="guides-section">
                  <dt>從這裡開始</dt>
                  <dd><a href="getting_started.html">Rails 入門</a></dd>
                </div>
                <div class="guides-section">
                  <dt>Models</dt>
                  <dd><a href="active_record_basics.html">Active Record 基礎知識</a></dd>
                  <dd><a href="active_record_migrations.html">Active Record Migrations</a></dd>
                  <dd><a href="active_record_validations.html">Active Record 驗證</a></dd>
                  <dd><a href="active_record_callbacks.html">Active Record Callbacks</a></dd>
                  <dd><a href="association_basics.html">Active Record Associations</a></dd>
                  <dd><a href="active_record_querying.html">Active Record 查詢介面</a></dd>
                </div>
                <div class="guides-section">
                  <dt>Views</dt>
                  <dd><a href="layouts_and_rendering.html">Rails 中的佈局和渲染</a></dd>
                  <dd><a href="form_helpers.html">Action View 表單 Helpers</a></dd>
                </div>
                <div class="guides-section">
                  <dt>Controllers</dt>
                  <dd><a href="action_controller_overview.html">Action Controller結束view</a></dd>
                  <dd><a href="routing.html">Rails 從外到內路由</a></dd>
                </div>
                <div class="guides-section">
                  <dt>其他元件</dt>
                  <dd><a href="active_support_core_extensions.html">Active Support 核心擴充套件</a></dd>
                  <dd><a href="action_mailer_basics.html">Action Mailer 基礎知識</a></dd>
                  <dd><a href="active_job_basics.html">現役工作基礎</a></dd>
                  <dd><a href="active_storage_overview.html">Active Storage 結束view</a></dd>
                  <dd><a href="action_cable_overview.html">Action Cable 結束 view</a></dd>
                  <dd><a href="webpacker.html">打包機</a></dd>
                </div>
                <div class="guides-section">
                  <dt>深層發掘</dt>
                  <dd><a href="i18n.html">Rails 國際化 (I18n) API</a></dd>
                  <dd><a href="testing.html">測試 Rails 應用程式</a></dd>
                  <dd><a href="security.html">保護 Rails 應用程式</a></dd>
                  <dd><a href="debugging_rails_applications.html">除錯 Rails 應用程式</a></dd>
                  <dd><a href="configuring.html">配置 Rails 應用程式</a></dd>
                  <dd><a href="command_line.html">Rails 命令列</a></dd>
                  <dd><a href="asset_pipeline.html">Asset Pipeline</a></dd>
                  <dd><a href="autoloading_and_reloading_constants.html">自動載入和重新載入常量</a></dd>
                  <dd><a href="caching_with_rails.html">使用 Rails 快取：結束view</a></dd>
                  <dd><a href="api_app.html">將 Rails 用於僅 API 的應用程式</a></dd>
                </div>
                <div class="guides-section">
                  <dt>延伸導軌</dt>
                  <dd><a href="rails_on_rack.html">機架上的導軌</a></dd>
                  <dd><a href="generators.html">建立和自定義 Rails 生成器和模板</a></dd>
                </div>
                <div class="guides-section">
                  <dt>貢獻</dt>
                  <dd><a href="contributing_to_ruby_on_rails.html">在 Rails 上為 Ruby 做貢獻</a></dd>
                  <dd><a href="api_documentation_guidelines.html">API 文件指南</a></dd>
                  <dd><a href="ruby_on_rails_guides_guidelines.html">指南指南</a></dd>
                </div>
                <div class="guides-section">
                  <dt>政策</dt>
                  <dd><a href="maintenance_policy.html">維修政策</a></dd>
                </div>
                <div class="guides-section">
                  <dt>發行說明</dt>
                  <dd><a href="upgrading_ruby_on_rails.html">在 Rails 上升級 Ruby</a></dd>
                  <dd><a href="6_1_release_notes.html">版本 6.1 - 2020 年 12 月</a></dd>
                  <dd><a href="6_0_release_notes.html">6.0 版 - 2019 年 8 月</a></dd>
                  <dd><a href="5_2_release_notes.html">5.2 版 - 2018 年 4 月</a></dd>
                  <dd><a href="5_1_release_notes.html">5.1 版 - 2017 年 4 月</a></dd>
                  <dd><a href="5_0_release_notes.html">5.0 版 - 2016 年 6 月</a></dd>
                  <dd><a href="4_2_release_notes.html">4.2 版 - 2014 年 12 月</a></dd>
                  <dd><a href="4_1_release_notes.html">4.1 版 - 2014 年 4 月</a></dd>
                  <dd><a href="4_0_release_notes.html">4.0 版 - 2013 年 6 月</a></dd>
                  <dd><a href="3_2_release_notes.html">3.2 版 - 2012 年 1 月</a></dd>
                  <dd><a href="3_1_release_notes.html">3.1 版 - 2011 年 8 月</a></dd>
                  <dd><a href="3_0_release_notes.html">3.0 版 - 2010 年 8 月</a></dd>
                  <dd><a href="2_3_release_notes.html">2.3 版 - 2009 年 3 月</a></dd>
                  <dd><a href="2_2_release_notes.html">2.2 版 - 2008 年 11 月</a></dd>
                </div>
            </dl>
          </div>
        </li>
        <li><a class="nav-item" href="contributing_to_ruby_on_rails.html">貢獻</a></li>
        <li class="guides-index guides-index-small">
          <select class="guides-index-item nav-item">
            <option value="index.html">指南索引</option>
              <optgroup label="從這裡開始">
                  <option value="getting_started.html">Rails 入門</option>
              </optgroup>
              <optgroup label="Models">
                  <option value="active_record_basics.html">Active Record 基礎知識</option>
                  <option value="active_record_migrations.html">Active Record Migrations</option>
                  <option value="active_record_validations.html">Active Record 驗證</option>
                  <option value="active_record_callbacks.html">Active Record Callbacks</option>
                  <option value="association_basics.html">Active Record Associations</option>
                  <option value="active_record_querying.html">Active Record 查詢介面</option>
              </optgroup>
              <optgroup label="Views">
                  <option value="layouts_and_rendering.html">Rails 中的佈局和渲染</option>
                  <option value="form_helpers.html">Action View 表單 Helpers</option>
              </optgroup>
              <optgroup label="Controllers">
                  <option value="action_controller_overview.html">Action Controller結束view</option>
                  <option value="routing.html">Rails 從外到內路由</option>
              </optgroup>
              <optgroup label="其他元件">
                  <option value="active_support_core_extensions.html">Active Support 核心擴充套件</option>
                  <option value="action_mailer_basics.html">Action Mailer 基礎知識</option>
                  <option value="active_job_basics.html">現役工作基礎</option>
                  <option value="active_storage_overview.html">Active Storage 結束view</option>
                  <option value="action_cable_overview.html">Action Cable 結束 view</option>
                  <option value="webpacker.html">打包機</option>
              </optgroup>
              <optgroup label="深層發掘">
                  <option value="i18n.html">Rails 國際化 (I18n) API</option>
                  <option value="testing.html">測試 Rails 應用程式</option>
                  <option value="security.html">保護 Rails 應用程式</option>
                  <option value="debugging_rails_applications.html">除錯 Rails 應用程式</option>
                  <option value="configuring.html">配置 Rails 應用程式</option>
                  <option value="command_line.html">Rails 命令列</option>
                  <option value="asset_pipeline.html">Asset Pipeline</option>
                  <option value="autoloading_and_reloading_constants.html">自動載入和重新載入常量</option>
                  <option value="caching_with_rails.html">使用 Rails 快取：結束view</option>
                  <option value="api_app.html">將 Rails 用於僅 API 的應用程式</option>
              </optgroup>
              <optgroup label="延伸導軌">
                  <option value="rails_on_rack.html">機架上的導軌</option>
                  <option value="generators.html">建立和自定義 Rails 生成器和模板</option>
              </optgroup>
              <optgroup label="貢獻">
                  <option value="contributing_to_ruby_on_rails.html">在 Rails 上為 Ruby 做貢獻</option>
                  <option value="api_documentation_guidelines.html">API 文件指南</option>
                  <option value="ruby_on_rails_guides_guidelines.html">指南指南</option>
              </optgroup>
              <optgroup label="政策">
                  <option value="maintenance_policy.html">維修政策</option>
              </optgroup>
              <optgroup label="發行說明">
                  <option value="upgrading_ruby_on_rails.html">在 Rails 上升級 Ruby</option>
                  <option value="6_1_release_notes.html">版本 6.1 - 2020 年 12 月</option>
                  <option value="6_0_release_notes.html">6.0 版 - 2019 年 8 月</option>
                  <option value="5_2_release_notes.html">5.2 版 - 2018 年 4 月</option>
                  <option value="5_1_release_notes.html">5.1 版 - 2017 年 4 月</option>
                  <option value="5_0_release_notes.html">5.0 版 - 2016 年 6 月</option>
                  <option value="4_2_release_notes.html">4.2 版 - 2014 年 12 月</option>
                  <option value="4_1_release_notes.html">4.1 版 - 2014 年 4 月</option>
                  <option value="4_0_release_notes.html">4.0 版 - 2013 年 6 月</option>
                  <option value="3_2_release_notes.html">3.2 版 - 2012 年 1 月</option>
                  <option value="3_1_release_notes.html">3.1 版 - 2011 年 8 月</option>
                  <option value="3_0_release_notes.html">3.0 版 - 2010 年 8 月</option>
                  <option value="2_3_release_notes.html">2.3 版 - 2009 年 3 月</option>
                  <option value="2_2_release_notes.html">2.2 版 - 2008 年 11 月</option>
              </optgroup>
          </select>
        </li>
      </ul>
    </div>
  </div>
  <hr class="hide" />

  <div id="feature">
    <div class="wrapper">
      <p><strong>請勿在 GITHUB 上閱讀此檔案，指南釋出在 <a href="https://guides.rubyonrails.org">https://guides.rubyonrails.org</a>.</strong></p><h2>使用 Rails 快取：結束view</h2><p>本指南介紹瞭如何使用快取加速 Rails 應用程式。</p><p>快取意味著儲存在請求-響應週期中生成的內容和
在響應類似請求時重用它。</p><p>快取通常是提高應用程式效能的最有效方法。
透過快取，網站在具有單個數據庫的單個伺服器上執行
可以承受數千個併發使用者的負載。</p><p>Rails 提供了一組開箱即用的快取功能。本指南將教
您瞭解其中每一項的範圍和目的。掌握這些技巧和你的
Rails 應用程式可以為數以百萬計的views 提供服務，而不會產生過多的響應時間
或伺服器賬單。</p><p>閱讀本指南後，您將瞭解：</p>
<ul>
<li>片段和俄羅斯娃娃快取。</li>
<li>如何管理快取依賴。</li>
<li>替代快取儲存。</li>
<li>有條件的 GET 支援。</li>
</ul>


                <div id="subCol">
            <h3 class="chapter"><img src="images/chapters_icon.gif" alt="" />Chapters</h3>
            <ol class="chapters">
<li>
<a href="#">基本快取</a>

<ul>
<li><a href="#">頁面快取</a></li>
<li><a href="#action">Action 快取</a></li>
<li><a href="#">片段快取</a></li>
<li><a href="#">俄羅斯娃娃快取</a></li>
<li><a href="#">共享部分快取</a></li>
<li><a href="#">管理依賴</a></li>
<li><a href="#">低階快取</a></li>
<li><a href="#sql">SQL 快取</a></li>
</ul>
</li>
<li>
<a href="#">快取儲存</a>

<ul>
<li><a href="#">配置</a></li>
<li><a href="#activesupport-cache-store">ActiveSupport::Cache::Store</a></li>
<li><a href="#activesupport-cache-memorystore">ActiveSupport::Cache::MemoryStore</a></li>
<li><a href="#activesupport-cache-filestore">ActiveSupport::Cache::FileStore</a></li>
<li><a href="#activesupport-cache-memcachestore">ActiveSupport::Cache::MemCacheStore</a></li>
<li><a href="#activesupport-cache-rediscachestore">ActiveSupport::Cache::RedisCacheStore</a></li>
<li><a href="#activesupport-cache-nullstore">ActiveSupport::Cache::NullStore</a></li>
</ul>
</li>
<li><a href="#keys">快取Keys</a></li>
<li>
<a href="#get">有條件的 GET 支援</a>

<ul>
<li><a href="#v-s-etag">強 v/s 弱 ETag</a></li>
</ul>
</li>
<li><a href="#">開發中的快取</a></li>
<li><a href="#">參考</a></li>
</ol>

          </div>

    </div>
  </div>

  <div id="container">
    <div class="wrapper">
      <div id="mainCol">
        <h3 id=""><a class="anchorlink" href="#">1 基本快取</a></h3><p>這是對三種快取技術的介紹：頁面、action 和
片段快取。預設情況下，Rails 提供片段快取。為了使用
頁面和action 快取，您需要新增<code>actionpack-page_caching</code> 和
<code>actionpack-action_caching</code> 到您的 <code>Gemfile</code>。</p><p>預設情況下，快取僅在您的生產環境中啟用。你可以玩
透過執行<code>rails dev:cache</code> 或透過設定在本地快取
<code>config/environments/development.rb</code> 中的 <code>config.action_controller.perform_caching</code> 到 <code>true</code>。</p><p>注意：更改<code>config.action_controller.perform_caching</code> 的value 將
只對Action Controller 提供的快取有影響。
例如，它不會影響我們解決的低階快取
<a href="#low-level-caching">下面</a>。</p><h4 id=""><a class="anchorlink" href="#">1.1 頁面快取</a></h4><p>頁面快取是一種 Rails 機制，它允許請求生成的頁面
由 Web 伺服器（即 Apache 或 NGINX）完成而無需去
透過整個 Rails 堆疊。雖然這是超快的，但它不能應用於
每種情況（例如需要身份驗證的頁面）。另外，由於
Web 伺服器直接從您需要的檔案系統提供檔案
實現快取過期。</p><p>資訊：頁面快取已從 Rails 4 中刪除。請參閱 <a href="https://github.com/rails/actionpack-page_caching">actionpack-page_caching gem</a>。</p><h4 id="action"><a class="anchorlink" href="#action">1.2 Action 快取</a></h4><p>頁面快取不能用於具有前置過濾器的操作 - 例如，需要身份驗證的頁面。這就是Action 快取的用武之地。Action 快取的工作方式類似於頁面快取，不同之處在於傳入的 Web 請求會命中 Rails 堆疊，以便在提供快取之前可以在其上執行過濾器。這允許執行身份驗證和其他限制，同時仍然提供快取副本的輸出結果。</p><p>資訊：Action 快取已從 Rails 4 中刪除。請參閱 <a href="https://github.com/rails/actionpack-action_caching">actionpack-action_caching gem</a>。請參閱 <a href="https://signalvnoise.com/posts/3113-how-key-based-cache-expiration-works">DHH 的基於 key 的快取過期超過view</a> 瞭解新的首選方法。</p><h4 id=""><a class="anchorlink" href="#">1.3 片段快取</a></h4><p>動態 Web 應用程式通常構建具有各種元件的頁面，而不是
所有這些都具有相同的快取特性。當不同部位
頁面需要單獨快取和過期，您可以使用片段快取。</p><p>片段快取允許將view 邏輯的片段包裝在快取塊中，並在下一個請求進入時從快取儲存中提供。</p><p>例如，如果你想快取頁面上的每個產品，你可以使用這個
程式碼：</p><div class="code_container">
<pre><code class="highlight erb"><span class="cp">&lt;%</span> <span class="vi">@products</span><span class="p">.</span><span class="nf">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">product</span><span class="o">|</span> <span class="cp">%&gt;</span>
  <span class="cp">&lt;%</span> <span class="n">cache</span> <span class="n">product</span> <span class="k">do</span> <span class="cp">%&gt;</span>
    <span class="cp">&lt;%=</span> <span class="n">render</span> <span class="n">product</span> <span class="cp">%&gt;</span>
  <span class="cp">&lt;%</span> <span class="k">end</span> <span class="cp">%&gt;</span>
<span class="cp">&lt;%</span> <span class="k">end</span> <span class="cp">%&gt;</span>
</code></pre>
<button class="clipboard-button" data-clipboard-text="&lt;% @products.each do |product| %&gt;
  &lt;% cache product do %&gt;
    &lt;%= render product %&gt;
  &lt;% end %&gt;
&lt;% end %&gt;
">Copy</button>
</div>
<p>當你的應用程式收到它對這個頁面的第一個請求時，Rails 會寫
具有唯一 key 的新快取條目。 key 看起來像這樣：</p><div class="code_container">
<pre><code class="highlight plaintext">views/products/index:bea67108094918eeba42cd4a6e786901/products/1
</code></pre>
<button class="clipboard-button" data-clipboard-text="views/products/index:bea67108094918eeba42cd4a6e786901/products/1
">Copy</button>
</div>
<p>中間的字串是模板樹摘要。這是一個雜湊
根據您正在快取的 view 片段的內容計算的摘要。如果
您更改view 片段（例如，HTML 更改），摘要將更改，
使現有檔案過期。</p><p>從產品記錄派生的快取版本儲存在快取條目中。
當產品被觸控時，快取版本發生變化，任何快取的片段
包含先前版本的將被忽略。</p><p>提示：像 Memcached 這樣的快取儲存會自動刪除舊的快取檔案。</p><p>如果要在某些條件下快取片段，可以使用
<code>cache_if</code> 或 <code>cache_unless</code>：</p><div class="code_container">
<pre><code class="highlight erb"><span class="cp">&lt;%</span> <span class="n">cache_if</span> <span class="n">admin?</span><span class="p">,</span> <span class="n">product</span> <span class="k">do</span> <span class="cp">%&gt;</span>
  <span class="cp">&lt;%=</span> <span class="n">render</span> <span class="n">product</span> <span class="cp">%&gt;</span>
<span class="cp">&lt;%</span> <span class="k">end</span> <span class="cp">%&gt;</span>
</code></pre>
<button class="clipboard-button" data-clipboard-text="&lt;% cache_if admin?, product do %&gt;
  &lt;%= render product %&gt;
&lt;% end %&gt;
">Copy</button>
</div>
<h5 id=""><a class="anchorlink" href="#">1.3.1 集合快取</a></h5><p><code>render</code> helper 還可以快取為集合呈現的各個模板。
它甚至可以透過讀取所有快取來使用 <code>each</code> 來完成前面的示例
一次而不是一個接一個模板。這是透過在呈現集合時傳遞 <code>cached: true</code> 來完成的：</p><div class="code_container">
<pre><code class="highlight erb"><span class="cp">&lt;%=</span> <span class="n">render</span> <span class="ss">partial: </span><span class="s1">'products/product'</span><span class="p">,</span> <span class="ss">collection: </span><span class="vi">@products</span><span class="p">,</span> <span class="ss">cached: </span><span class="kp">true</span> <span class="cp">%&gt;</span>
</code></pre>
<button class="clipboard-button" data-clipboard-text="&lt;%= render partial: 'products/product', collection: @products, cached: true %&gt;
">Copy</button>
</div>
<p>以前渲染中的所有快取模板將一次獲取很多
速度更快。此外，尚未快取的模板將是
寫入快取並在下一次渲染時多次提取。</p><h4 id=""><a class="anchorlink" href="#">1.4 俄羅斯娃娃快取</a></h4><p>您可能希望將快取片段巢狀在其他快取片段中。這是
稱為俄羅斯娃娃快取。</p><p>俄羅斯娃娃快取的優勢在於，如果單個產品更新，
所有其他內部片段在再生外部片段時都可以重複使用
分段。</p><p>如上一節所述，如果 value 的 value
<code>updated_at</code> 更改快取檔案直接依賴的記錄。
但是，這不會使片段巢狀在其中的任何快取過期。</p><p>例如，採用以下view：</p><div class="code_container">
<pre><code class="highlight erb"><span class="cp">&lt;%</span> <span class="n">cache</span> <span class="n">product</span> <span class="k">do</span> <span class="cp">%&gt;</span>
  <span class="cp">&lt;%=</span> <span class="n">render</span> <span class="n">product</span><span class="p">.</span><span class="nf">games</span> <span class="cp">%&gt;</span>
<span class="cp">&lt;%</span> <span class="k">end</span> <span class="cp">%&gt;</span>
</code></pre>
<button class="clipboard-button" data-clipboard-text="&lt;% cache product do %&gt;
  &lt;%= render product.games %&gt;
&lt;% end %&gt;
">Copy</button>
</div>
<p>這反過來呈現這個view：</p><div class="code_container">
<pre><code class="highlight erb"><span class="cp">&lt;%</span> <span class="n">cache</span> <span class="n">game</span> <span class="k">do</span> <span class="cp">%&gt;</span>
  <span class="cp">&lt;%=</span> <span class="n">render</span> <span class="n">game</span> <span class="cp">%&gt;</span>
<span class="cp">&lt;%</span> <span class="k">end</span> <span class="cp">%&gt;</span>
</code></pre>
<button class="clipboard-button" data-clipboard-text="&lt;% cache game do %&gt;
  &lt;%= render game %&gt;
&lt;% end %&gt;
">Copy</button>
</div>
<p>如果遊戲的任何屬性發生變化，<code>updated_at</code> value 將被設定為
當前時間，從而使快取過期。然而，因為<code>updated_at</code>
不會為產品物件更改，該快取不會過期，並且
您的應用程式將提供陳舊資料。為了解決這個問題，我們將 models 與
<code>touch</code> 方法：</p><div class="code_container">
<pre><code class="highlight ruby"><span class="k">class</span> <span class="nc">Product</span> <span class="o">&lt;</span> <span class="no">ApplicationRecord</span>
  <span class="n">has_many</span> <span class="ss">:games</span>
<span class="k">end</span>

<span class="k">class</span> <span class="nc">Game</span> <span class="o">&lt;</span> <span class="no">ApplicationRecord</span>
  <span class="n">belongs_to</span> <span class="ss">:product</span><span class="p">,</span> <span class="ss">touch: </span><span class="kp">true</span>
<span class="k">end</span>
</code></pre>
<button class="clipboard-button" data-clipboard-text="class Product &lt; ApplicationRecord
  has_many :games
end

class Game &lt; ApplicationRecord
  belongs_to :product, touch: true
end
">Copy</button>
</div>
<p>將<code>touch</code> 設定為<code>true</code> 後，任何action 都會為遊戲更改<code>updated_at</code>
記錄也會為相關產品更改它，從而使產品過期
快取。</p><h4 id=""><a class="anchorlink" href="#">1.5 共享部分快取</a></h4><p>可以在具有不同 mime 型別的檔案之間共享部分和關聯的快取。例如，共享部分快取允許模板編寫者在 HTML 和 JavaScript 檔案之間共享部分。在模板解析器檔案路徑中收集模板時，它們僅包含模板語言副檔名，而不包含 mime 型別。因為這個模板可以用於多種 mime 型別。 HTML 和 JavaScript 請求都會響應以下程式碼：</p><div class="code_container">
<pre><code class="highlight ruby"><span class="n">render</span><span class="p">(</span><span class="ss">partial: </span><span class="s1">'hotels/hotel'</span><span class="p">,</span> <span class="ss">collection: </span><span class="vi">@hotels</span><span class="p">,</span> <span class="ss">cached: </span><span class="kp">true</span><span class="p">)</span>
</code></pre>
<button class="clipboard-button" data-clipboard-text="render(partial: 'hotels/hotel', collection: @hotels, cached: true)
">Copy</button>
</div>
<p>將載入名為<code>hotels/hotel.erb</code> 的檔案。</p><p>另一種選擇是包含要渲染的部分的完整檔名。</p><div class="code_container">
<pre><code class="highlight ruby"><span class="n">render</span><span class="p">(</span><span class="ss">partial: </span><span class="s1">'hotels/hotel.html.erb'</span><span class="p">,</span> <span class="ss">collection: </span><span class="vi">@hotels</span><span class="p">,</span> <span class="ss">cached: </span><span class="kp">true</span><span class="p">)</span>
</code></pre>
<button class="clipboard-button" data-clipboard-text="render(partial: 'hotels/hotel.html.erb', collection: @hotels, cached: true)
">Copy</button>
</div>
<p>將在任何檔案 mime 型別中載入名為 <code>hotels/hotel.html.erb</code> 的檔案，例如您可以將此部分包含在 JavaScript 檔案中。</p><h4 id=""><a class="anchorlink" href="#">1.6 管理依賴</a></h4><p>為了正確地使快取無效，您需要正確定義
快取依賴項。 Rails 足夠聰明，可以處理常見的情況，所以你不會
必須指定任何東西。但是，有時，當您處理自定義
例如helpers，您需要明確定義它們。</p><h5 id=""><a class="anchorlink" href="#">1.6.1 隱式依賴</a></h5><p>大多數模板依賴都可以從模板中對<code>render</code> 的呼叫派生
本身。以下是<code>ActionView::Digestor</code> 知道的一些渲染呼叫示例
如何解碼：</p><div class="code_container">
<pre><code class="highlight ruby"><span class="n">render</span> <span class="ss">partial: </span><span class="s2">"comments/comment"</span><span class="p">,</span> <span class="ss">collection: </span><span class="n">commentable</span><span class="p">.</span><span class="nf">comments</span>
<span class="n">render</span> <span class="s2">"comments/comments"</span>
<span class="n">render</span> <span class="s1">'comments/comments'</span>
<span class="n">render</span><span class="p">(</span><span class="s1">'comments/comments'</span><span class="p">)</span>

<span class="n">render</span> <span class="s2">"header"</span> <span class="n">translates</span> <span class="n">to</span> <span class="n">render</span><span class="p">(</span><span class="s2">"comments/header"</span><span class="p">)</span>

<span class="n">render</span><span class="p">(</span><span class="vi">@topic</span><span class="p">)</span>         <span class="n">translates</span> <span class="n">to</span> <span class="n">render</span><span class="p">(</span><span class="s2">"topics/topic"</span><span class="p">)</span>
<span class="n">render</span><span class="p">(</span><span class="n">topics</span><span class="p">)</span>         <span class="n">translates</span> <span class="n">to</span> <span class="n">render</span><span class="p">(</span><span class="s2">"topics/topic"</span><span class="p">)</span>
<span class="n">render</span><span class="p">(</span><span class="n">message</span><span class="p">.</span><span class="nf">topics</span><span class="p">)</span> <span class="n">translates</span> <span class="n">to</span> <span class="n">render</span><span class="p">(</span><span class="s2">"topics/topic"</span><span class="p">)</span>
</code></pre>
<button class="clipboard-button" data-clipboard-text="render partial: &quot;comments/comment&quot;, collection: commentable.comments
render &quot;comments/comments&quot;
render 'comments/comments'
render('comments/comments')

render &quot;header&quot; translates to render(&quot;comments/header&quot;)

render(@topic)         translates to render(&quot;topics/topic&quot;)
render(topics)         translates to render(&quot;topics/topic&quot;)
render(message.topics) translates to render(&quot;topics/topic&quot;)
">Copy</button>
</div>
<p>另一方面，某些呼叫需要更改才能使快取正常工作。
例如，如果您要傳遞自定義集合，則需要更改：</p><div class="code_container">
<pre><code class="highlight ruby"><span class="n">render</span> <span class="vi">@project</span><span class="p">.</span><span class="nf">documents</span><span class="p">.</span><span class="nf">where</span><span class="p">(</span><span class="ss">published: </span><span class="kp">true</span><span class="p">)</span>
</code></pre>
<button class="clipboard-button" data-clipboard-text="render @project.documents.where(published: true)
">Copy</button>
</div>
<p>到：</p><div class="code_container">
<pre><code class="highlight ruby"><span class="n">render</span> <span class="ss">partial: </span><span class="s2">"documents/document"</span><span class="p">,</span> <span class="ss">collection: </span><span class="vi">@project</span><span class="p">.</span><span class="nf">documents</span><span class="p">.</span><span class="nf">where</span><span class="p">(</span><span class="ss">published: </span><span class="kp">true</span><span class="p">)</span>
</code></pre>
<button class="clipboard-button" data-clipboard-text='render partial: "documents/document", collection: @project.documents.where(published: true)
'>Copy</button>
</div>
<h5 id=""><a class="anchorlink" href="#">1.6.2 顯式依賴</a></h5><p>有時您會擁有根本無法派生的模板依賴項。這個
在helpers 中進行渲染時通常就是這種情況。下面是一個例子：</p><div class="code_container">
<pre><code class="highlight erb"><span class="cp">&lt;%=</span> <span class="n">render_sortable_todolists</span> <span class="vi">@project</span><span class="p">.</span><span class="nf">todolists</span> <span class="cp">%&gt;</span>
</code></pre>
<button class="clipboard-button" data-clipboard-text="&lt;%= render_sortable_todolists @project.todolists %&gt;
">Copy</button>
</div>
<p>您需要使用特殊的註釋格式來呼叫它們：</p><div class="code_container">
<pre><code class="highlight erb"><span class="c">&lt;%# Template Dependency: todolists/todolist %&gt;</span>
<span class="cp">&lt;%=</span> <span class="n">render_sortable_todolists</span> <span class="vi">@project</span><span class="p">.</span><span class="nf">todolists</span> <span class="cp">%&gt;</span>
</code></pre>
<button class="clipboard-button" data-clipboard-text="&lt;%# Template Dependency: todolists/todolist %&gt;
&lt;%= render_sortable_todolists @project.todolists %&gt;
">Copy</button>
</div>
<p>在某些情況下，比如單表繼承設定，你可能有一堆
顯式依賴。而不是寫出每個模板，你可以使用
萬用字元匹配目錄中的任何模板：</p><div class="code_container">
<pre><code class="highlight erb"><span class="c">&lt;%# Template Dependency: events/* %&gt;</span>
<span class="cp">&lt;%=</span> <span class="n">render_categorizable_events</span> <span class="vi">@person</span><span class="p">.</span><span class="nf">events</span> <span class="cp">%&gt;</span>
</code></pre>
<button class="clipboard-button" data-clipboard-text="&lt;%# Template Dependency: events/* %&gt;
&lt;%= render_categorizable_events @person.events %&gt;
">Copy</button>
</div>
<p>至於集合快取，如果部分模板沒有以乾淨的開頭
快取呼叫，您仍然可以透過新增特殊的集合快取來受益
模板中任意位置的註釋格式，例如：</p><div class="code_container">
<pre><code class="highlight erb"><span class="c">&lt;%# Template Collection: notification %&gt;</span>
<span class="cp">&lt;%</span> <span class="n">my_helper_that_calls_cache</span><span class="p">(</span><span class="n">some_arg</span><span class="p">,</span> <span class="n">notification</span><span class="p">)</span> <span class="k">do</span> <span class="cp">%&gt;</span>
  <span class="cp">&lt;%=</span> <span class="n">notification</span><span class="p">.</span><span class="nf">name</span> <span class="cp">%&gt;</span>
<span class="cp">&lt;%</span> <span class="k">end</span> <span class="cp">%&gt;</span>
</code></pre>
<button class="clipboard-button" data-clipboard-text="&lt;%# Template Collection: notification %&gt;
&lt;% my_helper_that_calls_cache(some_arg, notification) do %&gt;
  &lt;%= notification.name %&gt;
&lt;% end %&gt;
">Copy</button>
</div>
<h5 id=""><a class="anchorlink" href="#">1.6.3 外部依賴</a></h5><p>例如，如果您在快取塊中使用 helper 方法，然後更新
那個helper，你也必須提高快取。怎麼做都無所謂
你這樣做了，但模板檔案的 MD5 必須改變。一項建議是
只需在評論中明確表示，例如：</p><div class="code_container">
<pre><code class="highlight erb"><span class="c">&lt;%# Helper Dependency Updated: Jul 28, 2015 at 7pm %&gt;</span>
<span class="cp">&lt;%=</span> <span class="n">some_helper_method</span><span class="p">(</span><span class="n">person</span><span class="p">)</span> <span class="cp">%&gt;</span>
</code></pre>
<button class="clipboard-button" data-clipboard-text="&lt;%# Helper Dependency Updated: Jul 28, 2015 at 7pm %&gt;
&lt;%= some_helper_method(person) %&gt;
">Copy</button>
</div>
<h4 id=""><a class="anchorlink" href="#">1.7 低階快取</a></h4><p>有時您需要快取特定的value 或查詢結果而不是快取view 片段。 Rails 的快取機制非常適合儲存 <strong>any</strong> 型別的資訊。</p><p>實現低階快取的最有效方法是使用 <code>Rails.cache.fetch</code> 方法。此方法對快取進行讀取和寫入。當只傳遞一個引數時，key 被提取並從快取中返回value。如果傳遞了一個塊，則該塊將在快取記憶體未命中時執行。塊的返回value 將寫入給定快取key 下的快取，並返回該返回value。在快取命中的情況下，快取的value 將在不執行塊的情況下返回。</p><p>考慮以下示例。應用程式有一個<code>Product</code> model 和一個例項方法，用於在競爭網站上查詢產品的價格。此方法返回的資料非常適合低階快取：</p><div class="code_container">
<pre><code class="highlight ruby"><span class="k">class</span> <span class="nc">Product</span> <span class="o">&lt;</span> <span class="no">ApplicationRecord</span>
  <span class="k">def</span> <span class="nf">competing_price</span>
    <span class="no">Rails</span><span class="p">.</span><span class="nf">cache</span><span class="p">.</span><span class="nf">fetch</span><span class="p">(</span><span class="s2">"</span><span class="si">#{</span><span class="n">cache_key_with_version</span><span class="si">}</span><span class="s2">/competing_price"</span><span class="p">,</span> <span class="ss">expires_in: </span><span class="mi">12</span><span class="p">.</span><span class="nf">hours</span><span class="p">)</span> <span class="k">do</span>
      <span class="no">Competitor</span><span class="o">::</span><span class="no">API</span><span class="p">.</span><span class="nf">find_price</span><span class="p">(</span><span class="nb">id</span><span class="p">)</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre>
<button class="clipboard-button" data-clipboard-text='class Product &lt; ApplicationRecord
  def competing_price
    Rails.cache.fetch("#{cache_key_with_version}/competing_price", expires_in: 12.hours) do
      Competitor::API.find_price(id)
    end
  end
end
'>Copy</button>
</div>
<p>注意：請注意，在此示例中，我們使用了 @{_0} 方法，因此生成的快取 key 將類似於 <code>products/233-20140225082222765838000/competing_price</code>。 @{_0} 根據model 的類名、<code>id</code> 和<code>updated_at</code> 屬性生成一個字串。這是一個常見的約定，並且具有在產品更新時使快取失效的好處。一般來說，當你對例項級資訊使用低階快取時，你需要生成一個快取key。</p><h4 id="sql"><a class="anchorlink" href="#sql">1.8 SQL 快取</a></h4><p>查詢快取是 Rails 的一個特性，它快取每個返回的結果集
詢問。如果 Rails 再次遇到該請求的相同查詢，它將使用
快取的結果集，而不是對資料庫執行查詢
再次。</p><p>例如：</p><div class="code_container">
<pre><code class="highlight ruby"><span class="k">class</span> <span class="nc">ProductsController</span> <span class="o">&lt;</span> <span class="no">ApplicationController</span>

  <span class="k">def</span> <span class="nf">index</span>
    <span class="c1"># Run a find query</span>
    <span class="vi">@products</span> <span class="o">=</span> <span class="no">Product</span><span class="p">.</span><span class="nf">all</span>

    <span class="c1"># ...</span>

    <span class="c1"># Run the same query again</span>
    <span class="vi">@products</span> <span class="o">=</span> <span class="no">Product</span><span class="p">.</span><span class="nf">all</span>
  <span class="k">end</span>

<span class="k">end</span>
</code></pre>
<button class="clipboard-button" data-clipboard-text="class ProductsController &lt; ApplicationController

  def index
    # Run a find query
    @products = Product.all

    # ...

    # Run the same query again
    @products = Product.all
  end

end
">Copy</button>
</div>
<p>第二次對資料庫執行相同的查詢時，它實際上不會命中資料庫。第一次從查詢返回結果時，它儲存在查詢快取（記憶體中）中，第二次從記憶體中提取。</p><p>但是，重要的是要注意查詢快取是在開始時建立的
一個action 並在該action 的末尾銷燬，因此僅在
action 的持續時間。如果您想將查詢結果儲存在更多
持久時尚，您可以使用低階快取。</p><h3 id=""><a class="anchorlink" href="#">2 快取儲存</a></h3><p>Rails 為快取資料提供了不同的儲存（除了 SQL 和頁面
快取）。</p><h4 id=""><a class="anchorlink" href="#">2.1 配置</a></h4><p>您可以透過設定應用程式的預設快取儲存
<code>config.cache_store</code> 配置選項。其他引數可以作為
快取儲存建構函式的引數：</p><div class="code_container">
<pre><code class="highlight ruby"><span class="n">config</span><span class="p">.</span><span class="nf">cache_store</span> <span class="o">=</span> <span class="ss">:memory_store</span><span class="p">,</span> <span class="p">{</span> <span class="ss">size: </span><span class="mi">64</span><span class="p">.</span><span class="nf">megabytes</span> <span class="p">}</span>
</code></pre>
<button class="clipboard-button" data-clipboard-text="config.cache_store = :memory_store, { size: 64.megabytes }
">Copy</button>
</div>
<p>注意：或者，您可以在配置塊之外呼叫 <code>ActionController::Base.cache_store</code>。</p><p>您可以透過呼叫<code>Rails.cache</code> 來訪問快取。</p><h4 id="activesupport-cache-store"><a class="anchorlink" href="#activesupport-cache-store">2.2 ActiveSupport::Cache::Store</a></h4><p>此類為與 Rails 中的快取互動提供了基礎。這是一個抽象類，您不能單獨使用它。相反，您必須使用繫結到儲存引擎的類的具體實現。 Rails 附帶了以下記錄的幾個實現。</p><p>呼叫的主要方法有<code>read</code>、<code>write</code>、<code>delete</code>、<code>exist?</code>和<code>fetch</code>。 fetch 方法獲取一個塊並從快取中返回一個現有的value，或者如果value 不存在則評估該塊並將結果寫入快取。</p><p>有一些通用選項可供所有快取實現使用。這些可以傳遞給建構函式或與條目互動的各種方法。</p>
<ul>
<li><p><code>:namespace</code> - 此選項可用於在快取儲存中建立名稱空間。如果您的應用程式與其他應用程式共享快取，這將特別有用。</p></li>
<li><p><code>:compress</code> - 預設啟用。壓縮快取條目，以便在相同的記憶體佔用空間中儲存更多資料，從而減少快取逐出並提高命中率。</p></li>
<li><p><code>:compress_threshold</code> - 預設為 1kB。大於此閾值（以位元組為單位）的快取條目將被壓縮。</p></li>
<li><p><code>:expires_in</code> - 此選項設定快取條目的過期時間（以秒為單位），如果快取儲存支援它，它將自動從快取中刪除。</p></li>
<li><p><code>:race_condition_ttl</code> - 此選項與@{<em>1} 選項結合使用。它將透過防止多個程序同時重新生成相同的條目（也稱為狗堆效應）來防止快取條目過期時出現競爭條件。此選項設定在重新生成新 value 時可以重複使用過期條目的秒數。如果您使用@{</em>1} 選項，最好設定此value。</p></li>
<li><p><code>:coder</code> - 此選項允許用自定義的替換預設快取條目序列化機制。 <code>coder</code> 必須響應<code>dump</code> 和<code>load</code>，並傳遞自定義編碼器禁用自動壓縮。</p></li>
</ul>
<h5 id=""><a class="anchorlink" href="#">2.2.1 連線池選項</a></h5><p>預設情況下<code>MemCacheStore</code> 和<code>RedisCacheStore</code> 使用單個連線
每個程序。這意味著如果您使用 Puma 或其他執行緒伺服器，
您可以有多個執行緒等待連線可用。
要增加可用連線的數量，您可以啟用連線
彙集。</p><p>首先，將 <code>connection_pool</code> gem 新增到您的 Gemfile 中：</p><div class="code_container">
<pre><code class="highlight ruby"><span class="n">gem</span> <span class="s1">'connection_pool'</span>
</code></pre>
<button class="clipboard-button" data-clipboard-text="gem 'connection_pool'
">Copy</button>
</div>
<p>接下來，在配置快取儲存時傳遞<code>:pool_size</code> 和/或<code>:pool_timeout</code> 選項：</p><div class="code_container">
<pre><code class="highlight ruby"><span class="n">config</span><span class="p">.</span><span class="nf">cache_store</span> <span class="o">=</span> <span class="ss">:mem_cache_store</span><span class="p">,</span> <span class="s2">"cache.example.com"</span><span class="p">,</span> <span class="p">{</span> <span class="ss">pool_size: </span><span class="mi">5</span><span class="p">,</span> <span class="ss">pool_timeout: </span><span class="mi">5</span> <span class="p">}</span>
</code></pre>
<button class="clipboard-button" data-clipboard-text='config.cache_store = :mem_cache_store, "cache.example.com", { pool_size: 5, pool_timeout: 5 }
'>Copy</button>
</div>

<ul>
<li><p><code>:pool_size</code> - 此選項設定每個程序的連線數（預設為 5）。</p></li>
<li><p><code>:pool_timeout</code> - 此選項設定等待連線的秒數（預設為 5）。如果超時內沒有可用的連線，將引發<code>Timeout::Error</code>。</p></li>
</ul>
<h5 id=""><a class="anchorlink" href="#">2.2.2 自定義快取儲存</a></h5><p>您可以透過簡單地擴充套件來建立自己的自定義快取儲存
<code>ActiveSupport::Cache::Store</code> 並實現適當的方法。這邊走，
您可以將任意數量的快取技術交換到您的 Rails 應用程式中。</p><p>要使用自定義快取儲存，只需將快取儲存設定為您的新例項
自定義類。</p><div class="code_container">
<pre><code class="highlight ruby"><span class="n">config</span><span class="p">.</span><span class="nf">cache_store</span> <span class="o">=</span> <span class="no">MyCacheStore</span><span class="p">.</span><span class="nf">new</span>
</code></pre>
<button class="clipboard-button" data-clipboard-text="config.cache_store = MyCacheStore.new
">Copy</button>
</div>
<h4 id="activesupport-cache-memorystore"><a class="anchorlink" href="#activesupport-cache-memorystore">2.3 ActiveSupport::Cache::MemoryStore</a></h4><p>這個快取儲存在同一個Ruby 程序中將條目儲存在記憶體中。快取
透過將<code>:size</code> 選項傳送到
初始值設定項（預設為 32Mb）。當快取超過分配的大小時，
將進行清理，並刪除最近最少使用的條目。</p><div class="code_container">
<pre><code class="highlight ruby"><span class="n">config</span><span class="p">.</span><span class="nf">cache_store</span> <span class="o">=</span> <span class="ss">:memory_store</span><span class="p">,</span> <span class="p">{</span> <span class="ss">size: </span><span class="mi">64</span><span class="p">.</span><span class="nf">megabytes</span> <span class="p">}</span>
</code></pre>
<button class="clipboard-button" data-clipboard-text="config.cache_store = :memory_store, { size: 64.megabytes }
">Copy</button>
</div>
<p>如果您在 Rails 伺服器程序上執行多個 Ruby（就是這種情況
如果您使用的是 Phusion Passenger 或 puma 叢集模式），那麼您的 Rails 伺服器
流程例項將無法相互共享快取資料。這個快取
store 不適合大型應用程式部署。然而，它可以
適用於只有幾個伺服器程序的小型、低流量站點，
以及開發和測試環境。</p><p>預設情況下，新的 Rails 專案配置為在開發環境中使用此實現。</p><p>注意：由於程序在使用<code>:memory_store</code> 時不會共享快取資料，
無法透過 Rails 控制檯手動讀取、寫入或過期快取。</p><h4 id="activesupport-cache-filestore"><a class="anchorlink" href="#activesupport-cache-filestore">2.4 ActiveSupport::Cache::FileStore</a></h4><p>此快取儲存使用檔案系統來儲存條目。初始化快取時必須指定儲存檔案的目錄路徑。</p><div class="code_container">
<pre><code class="highlight ruby"><span class="n">config</span><span class="p">.</span><span class="nf">cache_store</span> <span class="o">=</span> <span class="ss">:file_store</span><span class="p">,</span> <span class="s2">"/path/to/cache/directory"</span>
</code></pre>
<button class="clipboard-button" data-clipboard-text='config.cache_store = :file_store, "/path/to/cache/directory"
'>Copy</button>
</div>
<p>使用這個快取儲存，同一主機上的多個伺服器程序可以共享一個
快取。此快取儲存適用於具有以下特點的中低流量站點
服務一兩個主機。執行在不同主機上的伺服器程序可以
使用共享檔案系統共享快取，但不推薦這種設定。</p><p>由於快取會一直增長到磁碟已滿，因此建議
定期清除舊條目。</p><p>這是預設的快取儲存實現（在<code>"#{root}/tmp/cache/"</code>），如果
沒有提供明確的<code>config.cache_store</code>。</p><h4 id="activesupport-cache-memcachestore"><a class="anchorlink" href="#activesupport-cache-memcachestore">2.5 ActiveSupport::Cache::MemCacheStore</a></h4><p>此快取儲存使用 Danga 的 <code>memcached</code> 伺服器為您的應用程式提供集中快取。 Rails 預設使用捆綁的 <code>dalli</code> gem。這是目前最流行的生產網站快取儲存。它可用於提供具有非常高的效能和冗餘的單個共享快取叢集。</p><p>初始化快取時，您應該為叢集中的所有 memcached 伺服器指定地址，或者確保已正確設定 <code>MEMCACHE_SERVERS</code> 環境變數。</p><div class="code_container">
<pre><code class="highlight ruby"><span class="n">config</span><span class="p">.</span><span class="nf">cache_store</span> <span class="o">=</span> <span class="ss">:mem_cache_store</span><span class="p">,</span> <span class="s2">"cache-1.example.com"</span><span class="p">,</span> <span class="s2">"cache-2.example.com"</span>
</code></pre>
<button class="clipboard-button" data-clipboard-text='config.cache_store = :mem_cache_store, "cache-1.example.com", "cache-2.example.com"
'>Copy</button>
</div>
<p>如果兩者都沒有指定，它將假定 memcached 在本地主機上的預設埠 (<code>127.0.0.1:11211</code>) 上執行，但這不是大型站點的理想設定。</p><div class="code_container">
<pre><code class="highlight ruby"><span class="n">config</span><span class="p">.</span><span class="nf">cache_store</span> <span class="o">=</span> <span class="ss">:mem_cache_store</span> <span class="c1"># Will fallback to $MEMCACHE_SERVERS, then 127.0.0.1:11211</span>
</code></pre>
<button class="clipboard-button" data-clipboard-text="config.cache_store = :mem_cache_store # Will fallback to $MEMCACHE_SERVERS, then 127.0.0.1:11211
">Copy</button>
</div>
<p>有關支援的地址型別，請參閱 <a href="https://www.rubydoc.info/github/mperham/dalli/Dalli%2FClient:initialize"><code>Dalli::Client</code> 文件</a>。</p><p>此快取上的 <code>write</code> 和 <code>fetch</code> 方法接受兩個額外的選項，這些選項利用了特定於 memcached 的功能。您可以指定 <code>:raw</code> 將值直接傳送到伺服器，無需序列化。該值必須是字串或數字。您只能在原始 values 上使用諸如 <code>increment</code> 和 <code>decrement</code> 之類的 memcached 直接操作。如果您不希望 memcached 覆蓋現有條目，您還可以指定 <code>:unless_exist</code>。</p><h4 id="activesupport-cache-rediscachestore"><a class="anchorlink" href="#activesupport-cache-rediscachestore">2.6 ActiveSupport::Cache::RedisCacheStore</a></h4><p>Redis 快取儲存利用 Redis 支援自動驅逐
當它達到最大記憶體時，讓它的行為很像 Memcached 快取伺服器。</p><p>部署說明：Redis 預設不會過期keys，所以請注意使用
專用的Redis快取伺服器。不要用你的持久 Redis 伺服器填滿
不穩定的快取資料！閱讀
【Redis快取伺服器設定指南】(<a href="https://redis.io/topics/lru-cache)%E8%A9%B3%E8%A7%A3%E3%80%82">https://redis.io/topics/lru-cache)詳解。</a></p><p>對於僅快取的 Redis 伺服器，將 <code>maxmemory-policy</code> 設定為 allkeys 的變體之一。
Redis 4+ 支援最不常用的驅逐（<code>allkeys-lfu</code>），一個很好的
預設選擇。 Redis 3 及更早版本應使用最近最少使用的驅逐 (<code>allkeys-lru</code>)。</p><p>將快取讀取和寫入超時設定得相對較低。重新生成快取的 value
通常比等待超過一秒鐘來檢索它更快。既讀又
寫入超時預設為 1 秒，但如果您的網路是
始終如一的低延遲。</p><p>預設情況下，快取儲存不會嘗試重新連線到 Redis，如果
請求期間連線失敗。如果您經常斷開連線
可能希望啟用重新連線嘗試。</p><p>快取讀取和寫入永遠不會引發異常；他們只是返回<code>nil</code>，
表現得好像快取中什麼都沒有。判斷你的快取是否是
遇到異常，您可以提供<code>error_handler</code> 以報告給
異常收集服務。它必須接受三個key字引數：<code>method</code>、
最初呼叫的快取儲存方法； <code>returning</code>，value
已返回給使用者，通常為<code>nil</code>；和<code>exception</code>，例外的是
被救出。</p><p>首先，將 redis gem 新增到您的 Gemfile：</p><div class="code_container">
<pre><code class="highlight ruby"><span class="n">gem</span> <span class="s1">'redis'</span>
</code></pre>
<button class="clipboard-button" data-clipboard-text="gem 'redis'
">Copy</button>
</div>
<p>您可以啟用對更快 <a href="https://github.com/redis/hiredis">hiredis</a> 的支援
透過將其 ruby 包裝器額外新增到您的 Gemfile 中來連線庫：</p><div class="code_container">
<pre><code class="highlight ruby"><span class="n">gem</span> <span class="s1">'hiredis'</span>
</code></pre>
<button class="clipboard-button" data-clipboard-text="gem 'hiredis'
">Copy</button>
</div>
<p>如果可用，Redis 快取儲存將自動要求並使用hiredis。沒有進一步的
需要配置。</p><p>最後在相關<code>config/environments/*.rb</code>檔案中新增配置：</p><div class="code_container">
<pre><code class="highlight ruby"><span class="n">config</span><span class="p">.</span><span class="nf">cache_store</span> <span class="o">=</span> <span class="ss">:redis_cache_store</span><span class="p">,</span> <span class="p">{</span> <span class="ss">url: </span><span class="no">ENV</span><span class="p">[</span><span class="s1">'REDIS_URL'</span><span class="p">]</span> <span class="p">}</span>
</code></pre>
<button class="clipboard-button" data-clipboard-text="config.cache_store = :redis_cache_store, { url: ENV['REDIS_URL'] }
">Copy</button>
</div>
<p>更復雜的生產 Redis 快取儲存可能如下所示：</p><div class="code_container">
<pre><code class="highlight ruby"><span class="n">cache_servers</span> <span class="o">=</span> <span class="sx">%w(redis://cache-01:6379/0 redis://cache-02:6379/0)</span>
<span class="n">config</span><span class="p">.</span><span class="nf">cache_store</span> <span class="o">=</span> <span class="ss">:redis_cache_store</span><span class="p">,</span> <span class="p">{</span> <span class="ss">url: </span><span class="n">cache_servers</span><span class="p">,</span>

  <span class="ss">connect_timeout:    </span><span class="mi">30</span><span class="p">,</span>  <span class="c1"># Defaults to 20 seconds</span>
  <span class="ss">read_timeout:       </span><span class="mf">0.2</span><span class="p">,</span> <span class="c1"># Defaults to 1 second</span>
  <span class="ss">write_timeout:      </span><span class="mf">0.2</span><span class="p">,</span> <span class="c1"># Defaults to 1 second</span>
  <span class="ss">reconnect_attempts: </span><span class="mi">1</span><span class="p">,</span>   <span class="c1"># Defaults to 0</span>

  <span class="ss">error_handler: </span><span class="o">-&gt;</span> <span class="p">(</span><span class="nb">method</span><span class="p">:,</span> <span class="n">returning</span><span class="p">:,</span> <span class="n">exception</span><span class="p">:)</span> <span class="p">{</span>
    <span class="c1"># Report errors to Sentry as warnings</span>
    <span class="no">Raven</span><span class="p">.</span><span class="nf">capture_exception</span> <span class="n">exception</span><span class="p">,</span> <span class="ss">level: </span><span class="s1">'warning'</span><span class="p">,</span>
      <span class="ss">tags: </span><span class="p">{</span> <span class="ss">method: </span><span class="nb">method</span><span class="p">,</span> <span class="ss">returning: </span><span class="n">returning</span> <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre>
<button class="clipboard-button" data-clipboard-text="cache_servers = %w(redis://cache-01:6379/0 redis://cache-02:6379/0)
config.cache_store = :redis_cache_store, { url: cache_servers,

  connect_timeout:    30,  # Defaults to 20 seconds
  read_timeout:       0.2, # Defaults to 1 second
  write_timeout:      0.2, # Defaults to 1 second
  reconnect_attempts: 1,   # Defaults to 0

  error_handler: -&gt; (method:, returning:, exception:) {
    # Report errors to Sentry as warnings
    Raven.capture_exception exception, level: 'warning',
      tags: { method: method, returning: returning }
  }
}
">Copy</button>
</div>
<h4 id="activesupport-cache-nullstore"><a class="anchorlink" href="#activesupport-cache-nullstore">2.7 ActiveSupport::Cache::NullStore</a></h4><p>此快取儲存範圍限定於每個 Web 請求，並在請求結束時清除儲存的 values。它旨在用於開發和測試環境。當您的程式碼直接與<code>Rails.cache</code> 互動但快取會干擾檢視程式碼更改的結果時，它會非常有用。</p><div class="code_container">
<pre><code class="highlight ruby"><span class="n">config</span><span class="p">.</span><span class="nf">cache_store</span> <span class="o">=</span> <span class="ss">:null_store</span>
</code></pre>
<button class="clipboard-button" data-clipboard-text="config.cache_store = :null_store
">Copy</button>
</div>
<h3 id="keys"><a class="anchorlink" href="#keys">3 快取Keys</a></h3><p>快取中使用的keys 可以是響應<code>cache_key</code> 或
<code>to_param</code>。如果需要，您可以在類上實現 <code>cache_key</code> 方法
生成自定義keys。 Active Record 會根據類名生成keys
並記錄id。</p><p>您可以使用values 的雜湊和陣列作為快取keys。</p><div class="code_container">
<pre><code class="highlight ruby"><span class="c1"># This is a legal cache key</span>
<span class="no">Rails</span><span class="p">.</span><span class="nf">cache</span><span class="p">.</span><span class="nf">read</span><span class="p">(</span><span class="ss">site: </span><span class="s2">"mysite"</span><span class="p">,</span> <span class="ss">owners: </span><span class="p">[</span><span class="n">owner_1</span><span class="p">,</span> <span class="n">owner_2</span><span class="p">])</span>
</code></pre>
<button class="clipboard-button" data-clipboard-text='# This is a legal cache key
Rails.cache.read(site: "mysite", owners: [owner_1, owner_2])
'>Copy</button>
</div>
<p>您在<code>Rails.cache</code> 上使用的keys 將與實際使用的不同
儲存引擎。它們可以使用名稱空間進行修改或更改以適應
技術後端約束。例如，這意味著您無法儲存
values 和 <code>Rails.cache</code> 然後嘗試用 <code>dalli</code> gem 把它們拉出來。
但是，您也不必擔心超出 memcached 大小限制或
違反語法規則。</p><h3 id="get"><a class="anchorlink" href="#get">4 有條件的 GET 支援</a></h3><p>條件 GET 是 HTTP 規範的一個特性，它為 Web 伺服器提供一種方法來告訴瀏覽器對 GET 請求的響應自上次請求以來沒有改變，並且可以安全地從瀏覽器快取中提取。</p><p>它們透過使用<code>HTTP_IF_NONE_MATCH</code> 和<code>HTTP_IF_MODIFIED_SINCE</code> 標頭來回傳遞唯一的內容識別符號和內容上次更改時間的時間戳來工作。如果瀏覽器發出請求，其中內容識別符號 (ETag) 或自時間戳記的最後一次修改與伺服器的版本匹配，則伺服器只需要發回一個未修改狀態的空響應。</p><p>查詢最後修改的時間戳和 if-none-match 標頭並確定是否發回完整響應是伺服器（即我們的）的責任。有了 Rails 中的條件獲取支援，這是一項非常簡單的任務：</p><div class="code_container">
<pre><code class="highlight ruby"><span class="k">class</span> <span class="nc">ProductsController</span> <span class="o">&lt;</span> <span class="no">ApplicationController</span>

  <span class="k">def</span> <span class="nf">show</span>
    <span class="vi">@product</span> <span class="o">=</span> <span class="no">Product</span><span class="p">.</span><span class="nf">find</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="ss">:id</span><span class="p">])</span>

    <span class="c1"># If the request is stale according to the given timestamp and etag value</span>
    <span class="c1"># (i.e. it needs to be processed again) then execute this block</span>
    <span class="k">if</span> <span class="n">stale?</span><span class="p">(</span><span class="ss">last_modified: </span><span class="vi">@product</span><span class="p">.</span><span class="nf">updated_at</span><span class="p">.</span><span class="nf">utc</span><span class="p">,</span> <span class="ss">etag: </span><span class="vi">@product</span><span class="p">.</span><span class="nf">cache_key_with_version</span><span class="p">)</span>
      <span class="n">respond_to</span> <span class="k">do</span> <span class="o">|</span><span class="n">wants</span><span class="o">|</span>
        <span class="c1"># ... normal response processing</span>
      <span class="k">end</span>
    <span class="k">end</span>

    <span class="c1"># If the request is fresh (i.e. it's not modified) then you don't need to do</span>
    <span class="c1"># anything. The default render checks for this using the parameters</span>
    <span class="c1"># used in the previous call to stale? and will automatically send a</span>
    <span class="c1"># :not_modified. So that's it, you're done.</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre>
<button class="clipboard-button" data-clipboard-text="class ProductsController &lt; ApplicationController

  def show
    @product = Product.find(params[:id])

    # If the request is stale according to the given timestamp and etag value
    # (i.e. it needs to be processed again) then execute this block
    if stale?(last_modified: @product.updated_at.utc, etag: @product.cache_key_with_version)
      respond_to do |wants|
        # ... normal response processing
      end
    end

    # If the request is fresh (i.e. it's not modified) then you don't need to do
    # anything. The default render checks for this using the parameters
    # used in the previous call to stale? and will automatically send a
    # :not_modified. So that's it, you're done.
  end
end
">Copy</button>
</div>
<p>除了選項雜湊，您還可以簡單地傳入model。 Rails 將使用<code>updated_at</code> 和<code>cache_key_with_version</code> 方法來設定<code>last_modified</code> 和<code>etag</code>：</p><div class="code_container">
<pre><code class="highlight ruby"><span class="k">class</span> <span class="nc">ProductsController</span> <span class="o">&lt;</span> <span class="no">ApplicationController</span>
  <span class="k">def</span> <span class="nf">show</span>
    <span class="vi">@product</span> <span class="o">=</span> <span class="no">Product</span><span class="p">.</span><span class="nf">find</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="ss">:id</span><span class="p">])</span>

    <span class="k">if</span> <span class="n">stale?</span><span class="p">(</span><span class="vi">@product</span><span class="p">)</span>
      <span class="n">respond_to</span> <span class="k">do</span> <span class="o">|</span><span class="n">wants</span><span class="o">|</span>
        <span class="c1"># ... normal response processing</span>
      <span class="k">end</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre>
<button class="clipboard-button" data-clipboard-text="class ProductsController &lt; ApplicationController
  def show
    @product = Product.find(params[:id])

    if stale?(@product)
      respond_to do |wants|
        # ... normal response processing
      end
    end
  end
end
">Copy</button>
</div>
<p>如果您沒有任何特殊的響應處理並且使用預設渲染機制（即您沒有使用<code>respond_to</code> 或自己呼叫渲染），那麼您在<code>fresh_when</code> 中有一個簡單的helper：</p><div class="code_container">
<pre><code class="highlight ruby"><span class="k">class</span> <span class="nc">ProductsController</span> <span class="o">&lt;</span> <span class="no">ApplicationController</span>

  <span class="c1"># This will automatically send back a :not_modified if the request is fresh,</span>
  <span class="c1"># and will render the default template (product.*) if it's stale.</span>

  <span class="k">def</span> <span class="nf">show</span>
    <span class="vi">@product</span> <span class="o">=</span> <span class="no">Product</span><span class="p">.</span><span class="nf">find</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="ss">:id</span><span class="p">])</span>
    <span class="n">fresh_when</span> <span class="ss">last_modified: </span><span class="vi">@product</span><span class="p">.</span><span class="nf">published_at</span><span class="p">.</span><span class="nf">utc</span><span class="p">,</span> <span class="ss">etag: </span><span class="vi">@product</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre>
<button class="clipboard-button" data-clipboard-text="class ProductsController &lt; ApplicationController

  # This will automatically send back a :not_modified if the request is fresh,
  # and will render the default template (product.*) if it's stale.

  def show
    @product = Product.find(params[:id])
    fresh_when last_modified: @product.published_at.utc, etag: @product
  end
end
">Copy</button>
</div>
<p>有時我們想要快取響應，例如一個靜態頁面，永遠不會得到
已到期。為了實現這一點，我們可以使用 <code>http_cache_forever</code> helper 並透過這樣做
所以瀏覽器和代理將無限期地快取它。</p><p>預設情況下快取的響應將是私有的，僅快取在使用者的網路上
瀏覽器。要允許代理快取響應，請設定<code>public: true</code> 以指示
他們可以為所有使用者提供快取的響應。</p><p>使用此helper，<code>last_modified</code> 標頭設定為<code>Time.new(2011, 1, 1).utc</code>
並且<code>expires</code> 標頭設定為 100 年。</p><p>警告：請謹慎使用此方法，因為瀏覽器/代理將無法失效
除非瀏覽器快取被強制清除，否則快取響應。</p><div class="code_container">
<pre><code class="highlight ruby"><span class="k">class</span> <span class="nc">HomeController</span> <span class="o">&lt;</span> <span class="no">ApplicationController</span>
  <span class="k">def</span> <span class="nf">index</span>
    <span class="n">http_cache_forever</span><span class="p">(</span><span class="ss">public: </span><span class="kp">true</span><span class="p">)</span> <span class="k">do</span>
      <span class="n">render</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre>
<button class="clipboard-button" data-clipboard-text="class HomeController &lt; ApplicationController
  def index
    http_cache_forever(public: true) do
      render
    end
  end
end
">Copy</button>
</div>
<h4 id="v-s-etag"><a class="anchorlink" href="#v-s-etag">4.1 強 v/s 弱 ETag</a></h4><p>Rails 預設生成弱 ETag。弱 ETag 允許語義等價
響應具有相同的 ETag，即使它們的身體不完全匹配。
當我們不希望頁面因細微變化而重新生成時，這很有用
響應體。</p><p>弱 ETag 有一個領先的 <code>W/</code> 以將它們與強 ETag 區分開來。</p><div class="code_container">
<pre><code class="highlight plaintext">W/"618bbc92e2d35ea1945008b42799b0e7" → Weak ETag
"618bbc92e2d35ea1945008b42799b0e7" → Strong ETag
</code></pre>
<button class="clipboard-button" data-clipboard-text='W/"618bbc92e2d35ea1945008b42799b0e7" → Weak ETag
"618bbc92e2d35ea1945008b42799b0e7" → Strong ETag
'>Copy</button>
</div>
<p>與弱 ETag 不同，強 ETag 意味著響應應該完全相同
和逐位元組相同。在一個範圍內執行 Range 請求時很有用
大影片或 PDF 檔案。一些 CDN 僅支援強大的 ETag，例如 Akamai。
如果您絕對需要生成一個強大的 ETag，可以按如下方式完成。</p><div class="code_container">
<pre><code class="highlight ruby"><span class="k">class</span> <span class="nc">ProductsController</span> <span class="o">&lt;</span> <span class="no">ApplicationController</span>
  <span class="k">def</span> <span class="nf">show</span>
    <span class="vi">@product</span> <span class="o">=</span> <span class="no">Product</span><span class="p">.</span><span class="nf">find</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="ss">:id</span><span class="p">])</span>
    <span class="n">fresh_when</span> <span class="ss">last_modified: </span><span class="vi">@product</span><span class="p">.</span><span class="nf">published_at</span><span class="p">.</span><span class="nf">utc</span><span class="p">,</span> <span class="ss">strong_etag: </span><span class="vi">@product</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre>
<button class="clipboard-button" data-clipboard-text="class ProductsController &lt; ApplicationController
  def show
    @product = Product.find(params[:id])
    fresh_when last_modified: @product.published_at.utc, strong_etag: @product
  end
end
">Copy</button>
</div>
<p>您還可以直接在響應上設定強 ETag。</p><div class="code_container">
<pre><code class="highlight ruby"><span class="n">response</span><span class="p">.</span><span class="nf">strong_etag</span> <span class="o">=</span> <span class="n">response</span><span class="p">.</span><span class="nf">body</span> <span class="c1"># =&gt; "618bbc92e2d35ea1945008b42799b0e7"</span>
</code></pre>
<button class="clipboard-button" data-clipboard-text='response.strong_etag = response.body # =&gt; "618bbc92e2d35ea1945008b42799b0e7"
'>Copy</button>
</div>
<h3 id=""><a class="anchorlink" href="#">5 開發中的快取</a></h3><p>想要測試應用程式的快取策略是很常見的
在開發模式。 Rails 提供了 rails 命令 <code>dev:cache</code> 來
輕鬆切換快取開/關。</p><div class="code_container">
<pre><code class="highlight console"><span class="gp">$</span><span class="w"> </span><span class="nb">bin/rails </span>dev:cache
<span class="go">Development mode is now being cached.
</span><span class="gp">$</span><span class="w"> </span><span class="nb">bin/rails </span>dev:cache
<span class="go">Development mode is no longer being cached.
</span></code></pre>
<button class="clipboard-button" data-clipboard-text="bin/rails dev:cache
bin/rails dev:cache
">Copy</button>
</div>
<p>注意：預設情況下，當開發模式快取為 <em>off</em> 時，Rails 使用
<a href="#activesupport-cache-nullstore"><code>ActiveSupport::Cache::NullStore</code></a>。</p><h3 id=""><a class="anchorlink" href="#">6 參考</a></h3>
<ul>
<li><a href="https://signalvnoise.com/posts/3113-how-key-based-cache-expiration-works">DHH 關於key-based 過期的文章</a></li>
<li><a href="http://railscasts.com/episodes/387-cache-digests">Ryan Bates 關於快取摘要的 Railscast</a></li>
</ul>


        <h3>反饋</h3>
        <p>
          我們鼓勵您幫助提高本指南的質量。
        </p>
        <p>
          如果您發現任何拼寫錯誤或事實錯誤，請貢獻。
          首先，您可以閱讀我們的 <a href="https://edgeguides.rubyonrails.org/contributing_to_ruby_on_rails.html#contributing-to-the-rails-documentation">文檔貢獻</a> 部分。
        </p>
        <p>
          您還可能會發現不完整的內容或不是最新的內容。
          請務必為 main 添加任何缺失的文檔。確保檢查
          <a href="https://edgeguides.rubyonrails.org">Edge Guides</a> 先驗證
          如果問題已經在主分支上解決。
          檢查 <a href="ruby_on_rails_guides_guidelines.html">Ruby on Rails 指南指南</a>
          風格和慣例。
        </p>
        <p>
          如果由於某種原因您發現需要修復但無法自行修補的內容，請
          <a href="https://github.com/rails/rails/issues">open an issue</a>。
        </p>
        <p>最後但並非最不重要的是，關於 Ruby on Rails 的任何討論
          <a href="https://discuss.rubyonrails.org/c/rubyonrails-docs">rubyonrails-docs 郵件列表</a> 上的文檔非常受歡迎。
        </p>
      </div>
    </div>
  </div>

  <hr class="hide" />
  <div id="footer">
    <div class="wrapper">
      <p>本作品已獲得<a href="https://creativecommons.org/licenses/by-sa/4.0/">知識共享署名-相同方式共享 4.0 國際</a>許可</p>
<p>“Rails”、“Ruby on Rails”和 Rails 標誌是 David Heinemeier Hansson 的商標。 保留所有權利。</p>
    </div>
  </div>
</body>
</html>
